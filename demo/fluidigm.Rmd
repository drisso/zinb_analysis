---
title: "Tests on fluidigm data set"
output: html_document
---

Attach package scRNAseq, select high quality cells, filter out those which do not have at least 10 counts in at least 10 cells and run zinb
```{r, eval=TRUE}
library(SummarizedExperiment)
library(scRNAseq)
data("fluidigm")
high.cov.cells=assays(fluidigm)$counts[,which(colData(fluidigm)$Coverage_Type=="High")]
filter.out=apply(high.cov.cells>10,1,sum)<10
```
Number of genes which remain:
```{r}
print(sum(!filter.out)) 
```

Select those genes and run zinb PCA:

```{r}
fluidigm2=t(high.cov.cells[!filter.out,])
zinb.fluidigm=zinb.PCA(fluidigm2,no_cores=7,alt.number=25,verbose=TRUE)
```

Plot the results with cells colored according to their cluster

```{r, echo=FALSE}
plot(zinb.fluidigm$U,col=colData(fluidigm)$Cluster2[colData(fluidigm)$Coverage_Type=="High"])
```

Remark that points are almost aligned along a line suggesting that the correlation between columns of U is very high:

```{r}
print(cor(zinb.fluidigm$U[,1],zinb.fluidigm$U[,2]),method="spearman")
```

Check the correlations between two zinb factors, the total numbers of reads and the total numbers of detected genes.

```{r,eval=TRUE}
#first factor and total number of detected genes in the cell

cor(zinb.fluidigm$U[,1],rowSums(fluidigm2!=0),method="spearman")
#second factor and the total number of detected genes in the cell

cor(zinb.fluidigm$U[,2],rowSums(fluidigm2!=0),method="spearman")
#first factor and the total number of counts in the cell

cor(zinb.fluidigm$U[,1],rowSums(fluidigm2),method="spearman")
#second factor and the total number of counts in the cell

cor(zinb.fluidigm$U[,2],rowSums(fluidigm2),method="spearman")
```

Plot the first and then the second column of U versus the total number of counts:

```{r`, echo = FALSE}
plot(rowSums(fluidigm2),zinb.fluidigm$U[,1])
plot(rowSums(fluidigm2),zinb.fluidigm$U[,2])
```

Plot the first and then the second column of U versus the total number detected genes:

```{r echo = FALSE}
plot(rowSums(fluidigm2!=0),zinb.fluidigm$U[,1])
plot(rowSums(fluidigm2!=0),zinb.fluidigm$U[,2])
```

One modification to take into account the library size (seems to work)

leads to function zinb.PCA.correct.sf (about which we were speaking last time): consists to fit logM = X.mu * a.mu + Y.mu * b + SF * I, where SF is a column of cell's size factors to be estimated and I is a line of ones. 

When optimizing wrt to V and W: the vector SF is given as offset for each of the genes 
When optimizing wrt U: SF is learned as the 3-rd line of b, where Y.mu is taken as V concatenated with I and Y.pi is taken as W concatenated with a column of zeros (to fix the problem of size).

```{r}
zinb.fluidigm.SF=zinb.PCA.correct.sf(fluidigm2,no_cores=7,alt.number=25,verbose=TRUE)
```

Plot the result (quite different):

```{r, echo=FALSE}
plot(zinb.fluidigm.SF$U,col=colData(fluidigm)$Cluster2[colData(fluidigm)$Coverage_Type=="High"])
```

Check correlations with total reads and total detected:

```{r,eval=TRUE}
#first factor and total number of detected genes in the cell

cor(zinb.fluidigm.SF$U[,1],rowSums(fluidigm2!=0),method="spearman")
#second factor and the total number of detected genes in the cell

cor(zinb.fluidigm.SF$U[,2],rowSums(fluidigm2!=0),method="spearman")
#first factor and the total number of counts in the cell

cor(zinb.fluidigm.SF$U[,1],rowSums(fluidigm2),method="spearman")
#second factor and the total number of counts in the cell

cor(zinb.fluidigm.SF$U[,2],rowSums(fluidigm2),method="spearman")
```

First factor still captures the number of detected genes. May help to add another "size factor" vector but this time to the logitPi part?

Second possible modification (not working yet):

The high correlation between the first factor and the total number of reads suggests adding this variable explicitely as the known cell level covariate as a possible way of normalization. 

Modification of the first step (optimization wrt right parts): we need to add a known design matrix containing the total number of reads and the total number of detected genes. Its coefficients are to be estimated in the first step with V and W. For that, we give as X.mu the concatenation of U with Xtech.mu and the same for X.pi.

Modification of the second step (optimization wrt U): for the moment, the code does not (does it?) give an explicit possibility to give known X.mu, a.mu, X.pi and a.pi to the step which optimizes in U. I pass those     arguments as offsets.

There is something wrong this function because it stops after very few iterations and the result does not look very different from PCA. Here are results:

```{r}
zinb.fluidigm.SF2=zinb.PCA.correct.for.sf2(fluidigm2,no_cores=7,alt.number=25,verbose=TRUE)
```

Plot the result:

```{r, echo = FALSE}
plot(zinb.fluidigm.SF2$U,col=colData(fluidigm)$Cluster1[colData(fluidigm)$Coverage_Type=="High"],main="zinb.fluidigm.SF2")
plot(prcomp(log(1+fluidigm2),scale.=TRUE,center=TRUE)$x[,1:2],col=colData(fluidigm)$Cluster1[colData(fluidigm)$Coverage_Type=="High"],main="PCA")
```



