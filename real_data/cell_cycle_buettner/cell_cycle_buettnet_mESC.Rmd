---
title: "Cell cycle - Buettner mESC dataset"
author: "Fanny Perraudeau"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: 
  html_document: 
    fig_height: 7
    fig_width: 7
    toc: yes
    code_folding: hide
    toc_float: yes
---

```{r options, echo=FALSE, results="hide",message=FALSE, error=FALSE, include=FALSE, autodep=TRUE}
knitr::opts_chunk$set(fig.align="center", cache=TRUE, error=FALSE, message=FALSE, warning=TRUE)
library(zinbwave)
library(RColorBrewer)
library(ggplot2)
library(readxl)
library(BiocParallel)
library(doParallel)
set.seed(9843)
```

```{r parallel}
NCORES = 2
mysystem = Sys.info()[['sysname']]
if (mysystem == 'Darwin'){
  registerDoParallel(NCORES)
  register(DoparParam())
}else if (mysystem == 'Linux'){
  register(bpstart(MulticoreParam(workers=NCORES)))
}else{
  print('Please change this to allow parallel computing')
  register(SerialParam())
}
```


In paper "Computational analysis of cell-to-cell heterogeneity in single-cell RNA-sequencing data reveals hidden subpopulations of cells" (Buettner et al), they use a dataset with 182 cells and about 9000 genes (fluidigm C1) where they know the cell cycle status of the cells (G1, S, or G2M). Let's see if we can use this dataset to demonstrate the ability of zinbwave to extract wanted/unwanted variance. We would to show that we can remove unwanted cell-cycle effect.

# Preprocessing

We filter cells and genes as in the paper.

```{r}
path = 'E-MTAB-2805.processed.1/'
keepgenes = read_excel('keptgenes_buettner_suppldata2.xlsx', sheet = 2)
keepgenes = colnames(keepgenes)
fn = list.files(path)
pal = brewer.pal(9, "Set1")[1:3]
par(mfrow=c(1,3))
counts = lapply(fn, function(y){
  xx = read.table(paste0(path, y), stringsAsFactors = F, header = T)
  tot = unlist(xx[xx$EnsemblGeneID == 'Aligned', 5:ncol(xx)])
  endo = colSums(xx[!grepl('ERCC|Ambiguous|No_feature|Not_aligned|Too_low_aQual|Aligned', xx$EnsemblGeneID), 5:ncol(xx)])
  detected = colSums(xx[1:(nrow(xx)-5), 5:ncol(xx)]!=0)
  percQC = unlist(xx[xx$EnsemblGeneID=='Too_low_aQual', 5:ncol(xx)]) / tot

  mito = read.csv('~/Documents/scRNAseq/scRNAseq-zinbwave/neuroblastoma/data/Mouse.MitoCarta2.0.txt', header = T,
                              sep = '\t', stringsAsFactors = F)
  mito = unique(mito[mito$TrainingDataset %in% c('Tmito'), 'EnsemblGeneID'])
  mito = colSums(xx[xx$EnsemblGeneID %in% mito, 5:ncol(xx)])

  filt = tot < 0.5*10^6 | detected < 6000 | percQC > .1 | mito/endo > .15
  xx = cbind(xx[, 1:4], xx[, 5:ncol(xx)][, !filt])

  ratio = endo/tot
  ratio = ratio[!filt]
  hist(ratio, breaks = seq(0,1,length.out = 20), xlim = c(0,1), freq = F,
       xlab = 'Endogenous reads/Total mapped reads', main = strsplit(y, '_')[[1]][1])
  med = median(ratio)
  mad = mad(ratio)
  abline(v = med, col = 'blue')
  abline(v = med+mad, col = 'red')
  abline(v = med-mad, col = 'red')

  xx = xx[xx$AssociatedGeneName %in% keepgenes, ]
  xx = xx[, c(3, 5:ncol(xx))]
  xx$AssociatedGeneName = factor(xx$AssociatedGeneName)
  xx = stats::aggregate(. ~ AssociatedGeneName, data =  xx, FUN = max)
  rownames(xx) = as.vector(xx$AssociatedGeneName)
  xx = xx[, 2:ncol(xx)]
  xx[, (ratio < med + mad) & (ratio > med - mad)]
})

stopifnot(all.equal(rownames(counts[[1]]), rownames(counts[[2]])))
stopifnot(all.equal(rownames(counts[[3]]), rownames(counts[[2]])))
counts = do.call(cbind, counts)
counts = as.matrix(counts)
counts = counts[rowSums(counts>10)>=10, ]
dim(counts)
```

```{r}
cellcycle = sapply(colnames(counts), function(x) strsplit(x, '_')[[1]][1])
table(cellcycle)
names(pal) = unique(cellcycle)
```

# Fit zinbwave

```{r}
eps = ncol(counts)
```

We fit zinbwave with K = 2 and X an intercept only. I tried higher K but results are similar.
```{r}
set.seed(89303)
print(system.time(zinb <- zinbFit(Y = counts, K = 2, epsilon = eps)))
```


```{r}
par(mfrow=c(1,3))
plot(zinb@W, col = pal[cellcycle], main = 'ZINB W, K = 2, X intercept')
legend(x = 'bottomright', legend = names(pal), cex = .5, fill = pal,
       title = 'Known Cell Cycle')

km = kmeans(zinb@W, centers = 3)
labs_k3 = km$cluster
table(labs_k3, cellcycle)
plot(zinb@W, col = labs_k3, main = 'ZINB W, K = 2, X intercept')
legend(x = 'bottomright', legend = unique(labs_k3), cex = .5,
       fill = unique(labs_k3), title = 'Kmeans, k = 3')

km = kmeans(zinb@W, centers = 4)
labs_k4 = km$cluster
table(labs_k4, cellcycle)
plot(zinb@W, col = labs_k4, main = 'ZINB W, K = 2, X intercept')
legend(x = 'bottomright', legend = unique(labs_k4), cex = .5, fill = unique(labs_k4),
       title = 'Kmeans, k = 4')
```

We have a set of genes known to be associated with cell cycle. What measure could we compute to show that correlation with cell cycle when X = int and no more correlation with cell cycle when x = (int, labs)
```{r}
ccgenes = read.csv('cellcyclegenes_buettner_suppltable1.csv', stringsAsFactors = F)
ccgenes = ccgenes[,1]
head(ccgenes)
```

# Fit zinb using learnt labels
We fit zinb where X = c(int, learnt clusters from kmeans)
```{r}
X = model.matrix(~ labs_k3)
eps = 10000
print(system.time(zinb_learnt_k3 <- zinbFit(Y = counts, K = 2, X = X, epsilon = eps)))
```

```{r}
par(mfrow = c(1,2))
main = 'ZINB W, K = 2, X = labels learnt from kmeans k = 3'
plot(zinb_learnt_k3@W, col = pal[cellcycle], main=main)
legend(x = 'bottomright', legend = names(pal), fill = pal, title = 'Cell cycle')
plot(zinb_learnt_k3@W, col = labs_k3, main = main)
legend(x = 'bottomright', legend = unique(labs_k3), fill = unique(labs_k3),
       title = 'Kmeans k=3')
```

```{r}
X = model.matrix(~ labs_k4)
print(system.time(zinb_learnt_k4 <- zinbFit(Y = counts, K = 2, X = X, epsilon = eps)))
```

```{r}
par(mfrow = c(1,2))
main = 'ZINB W, K = 2, X = labels learnt from kmeans k = 4'
plot(zinb_learnt_k4@W, col = pal[cellcycle], main=main)
legend(x = 'bottomright', legend = names(pal), fill = pal, title = 'Cell cycle')
plot(zinb_learnt_k4@W, col = labs_k4, main = main)
legend(x = 'bottomright', legend = unique(labs_k4), fill = unique(labs_k4),
       title = 'Kmeans k=4')
```



# Fit zinb using known cell cycle status

We fit zinb where X = c(int, known cell cycle status)
```{r}
X = model.matrix(~ cellcycle)
print(system.time(zinb_known_cl <- zinbFit(Y = counts, K = 2, X = X, epsilon = eps)))
```
```{r}
plot(zinb_known_cl@W, col = pal[cellcycle], main = 'ZINB W, K = 2, X = known cell cycle status')
legend(x = 'bottomright', legend = names(pal), cex = .5, fill = pal,
       title = 'Known Cell Cycle')
```


# Length bias

When I downloaded the data, I had access to the length of the genes. So, I just took a look at what happen when we add log(gene length) in V. As you see in the first plot, there is no gene length bias. So, as you see in the second and as expected, no effect of gene length on the clustering.

```{r}
xx = read.table(paste0(path, fn[1]), stringsAsFactors = F, header = T)
len = xx[,'GeneLength']
names(len) = xx[,'EnsemblGeneID']

aveLogCounts = Matrix::rowMeans(log1p(xx[1:(nrow(xx)-97),
                                         colnames(xx) %in% colnames(counts)]))
len_bins = cut_number(xx$GeneLength[1:(nrow(xx)-97)], 10)
boxplot(aveLogCounts ~ len_bins, las=2, main = 'Investigate length bias - all genes',
        ylab = 'Average log counts')
```

```{r}
xx = read.table(paste0(path, fn[1]), stringsAsFactors = F, header = T)
xx = xx[, c('AssociatedGeneName', 'GeneLength')]
xx = xx[xx$AssociatedGeneName %in% rownames(counts), ]
xx$AssociatedGeneName = factor(xx$AssociatedGeneName)
xx = stats::aggregate(GeneLength ~ AssociatedGeneName, xx, mean)
len = xx[,2]
names(len) = xx[,1]
len = len[rownames(counts)]
aveLogCounts = Matrix::rowMeans(log1p(counts))
len_bins = cut_number(len, 10)
boxplot(aveLogCounts ~ len_bins, las=2, main = 'Investigate length bias',
        ylab = 'Average log counts')
```

```{r zinbLength}
set.seed(89303)
V = model.matrix( ~ log(len))
print(system.time(zinb_len <- zinbFit(Y = counts, K = 2, V = V, epsilon = eps)))
```

```{r}
par(mfrow = c(1,2))
plot(zinb@W, col = pal[cellcycle], main = 'ZINB W, K = 2, no V')
plot(zinb_len@W, col = pal[cellcycle], main = 'ZINB W, K = 2, log length in V')
legend(x = 'bottomright', legend = names(pal), cex = .5, fill = pal,
       title = 'Known Cell Cycle')
```


```{r}
par(mfrow=c(1,2))
plot(zinb_len@W, col = pal[cellcycle], main = 'ZINB W, K = 2, X intercept')
legend(x = 'bottomright', legend = names(pal), cex = .5, fill = pal,
       title = 'Known Cell Cycle')

km = kmeans(zinb_len@W, centers = 3)
labs_k3 = km$cluster
table(labs_k3, cellcycle)
plot(zinb_len@W, col = labs_k3, main = 'ZINB W, K = 2, X intercept')
legend(x = 'bottomright', legend = unique(labs_k3), cex = .5,
       fill = unique(labs_k3), title = 'Kmeans, k = 3')
```

```{r}
X = model.matrix(~ labs_k3)
print(system.time(zinb_learnt_k3 <- zinbFit(Y = counts, K = 2, X = X, V=V, epsilon = eps)))
```

```{r}
par(mfrow = c(1,2))
main = 'ZINB W, K = 2, X = labels learnt from kmeans k = 3'
plot(zinb_learnt_k3@W, col = pal[cellcycle], main=main)
legend(x = 'bottomright', legend = names(pal), fill = pal, title = 'Cell cycle')
plot(zinb_learnt_k3@W, col = labs_k3, main = main)
legend(x = 'bottomright', legend = unique(labs_k3), fill = unique(labs_k3),
       title = 'Kmeans k=3')
```

