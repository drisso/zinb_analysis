---
title: "Unsupervised: compare PCA to a 2-dimensional projection based on ZINB"
output: 
  html_document: 
    fig_height: 10
    fig_width: 10
    toc: yes
    code_folding: hide
    toc_float: yes
---

```{r options, echo=FALSE, results="hide",mesasge=FALSE, error=FALSE, include=FALSE, autodep=TRUE}
knitr::opts_chunk$set(fig.align="center", cache=TRUE, error=FALSE, message=FALSE, warning=FALSE)
library(SummarizedExperiment)
library(scRNAseq)
library(zinb)
library(scran)
library(EDASeq)
library(ggplot2)
library(magrittr)

library(RColorBrewer)
cols <- brewer.pal(8, "Set1")
cols2 <- brewer.pal(8, "Set2")
```

# TL;DR

The zinb model doesn't seem to work well in the Fluidigm data. This is independent of normalization, meaning that both unnormalized data and normalized data (both with scran and full-quantile) lead to bad results.

PCA leads to better results, even though, as many people have shown, the first component is highly correlated to detection rate, even after normalization.

ZIFA seems to work well in the Fluidigm datasets, suggesting that we should be able to find a way to make zinb work as well.

One key difference between ZIFA and zinb is that in our model both $\mu$ and $\pi$ depend on $W$, while in the ZIFA model only $\mu$ does. We should consider a model that doesn't have a $W$ in $\pi$.

It seems (preliminary analyses) that removing the intercept in V makes the weird W behavior go away. Still, I think that we should add the ability to remove W from $\pi$ and see what is the difference.

# High coverage data

Select high coverage cells, filter out the genes that do not have at least 10 counts in at least 10 cells.

```{r datain}
data("fluidigm")
fluidigm_high <- fluidigm[,which(colData(fluidigm)$Coverage_Type=="High")]
filter <- apply(assay(fluidigm_high)>10, 1, sum)>=10
```

Number of retained genes:
```{r}
print(sum(filter))
```

## No normalization

Fit a zinb model on the high coverage data (no normalization).

```{r filtering}
fluidigm_high <- fluidigm_high[filter,]
high <- assay(fluidigm_high)
```

```{r zinb}
set.seed(23424)
print(system.time(zinb_high <- zinbFit(high, ncores = 3, K = 2)))
```

Plot the results with cells colored according to their biological condition.

```{r zinb_plot}
bio <- as.factor(colData(fluidigm_high)$Biological_Condition)
cl <- as.factor(colData(fluidigm_high)$Cluster2)

plot(zinb_high@W, col=cols[bio], pch=19, xlab="W1", ylab="W2")
legend("topleft", levels(bio), fill=cols)

plot(zinb_high@W, col=cols2[cl], pch=19, xlab="W1", ylab="W2")
legend("topleft", levels(cl), fill=cols2)
```

Compared to PCA (of the log counts)

```{r pca}
pca <- prcomp(t(log1p(high)))
plot(pca$x, col=cols[bio], pch=19)
legend("topleft", levels(bio), fill=cols)

plot(pca$x, col=cols2[cl], pch=19)
legend("topleft", levels(cl), fill=cols2)
```

Check the correlations between two zinb factors, the total numbers of reads and the total numbers of detected genes.

```{r corr, echo=TRUE}
#first factor and total number of detected genes in the cell
cor(zinb_high@W[,1], colSums(high>0),method="spearman")

#second factor and the total number of detected genes in the cell
cor(zinb_high@W[,2], colSums(high>0),method="spearman")


#first factor and the total number of counts in the cell
cor(zinb_high@W[,1], colSums(high),method="spearman")

#second factor and the total number of counts in the cell
cor(zinb_high@W[,2], colSums(high),method="spearman")
```

Same for PCA

```{r corr2, echo=TRUE}
#first factor and total number of detected genes in the cell
cor(pca$x[,1], colSums(high>0), method="spearman")

#second factor and the total number of detected genes in the cell
cor(pca$x[,2], colSums(high>0), method="spearman")


#first factor and the total number of counts in the cell
cor(pca$x[,1], colSums(high), method="spearman")

#second factor and the total number of counts in the cell
cor(pca$x[,2], colSums(high), method="spearman")
```

Correlation between PCA and ZINB

```{r corr3, echo=TRUE}
cor(pca$x[,1], zinb_high@W[,1], method="spearman")
cor(pca$x[,2], zinb_high@W[,1], method="spearman")
cor(pca$x[,1], zinb_high@W[,2], method="spearman")
cor(pca$x[,2], zinb_high@W[,2], method="spearman")
```

## Using scran size factors

```{r scran}
sce <- newSCESet(countData=data.frame(high))
sce <- computeSumFactors(sce, sizes=c(10, 20, 30))

sf <- sizeFactors(sce)

norm <- exprs(convertTo(sce, type="monocle"))
fq <- betweenLaneNormalization(high, which="full")

plotRLE(high, outline=FALSE, col=cols[bio], main="Unnormalized counts")
plotRLE(norm, outline=FALSE, col=cols[bio], main="SCRAN normalization")
plotRLE(fq, outline=FALSE, col=cols[bio], main="FQ normalization")
```

I'm not convinced that this is the best normalization, but since it's the only one specifically proposed for scRNA-seq, it's a good place to start.

```{r zinb_scran}
set.seed(3525)
offsets <- matrix(rep(sf, NROW(high)), ncol=NROW(high), nrow=NCOL(high))
print(system.time(zinb_norm <- zinbFit(high, ncores = 3, K = 2, O_mu = offsets)))
```

Plot the results with cells colored according to their biological condition.

```{r zinb_scran_plot}
plot(zinb_norm@W, col=cols[bio], pch=19, xlab="W1", ylab="W2")
legend("topleft", levels(bio), fill=cols)

plot(zinb_norm@W, col=cols2[cl], pch=19, xlab="W1", ylab="W2")
legend("topleft", levels(cl), fill=cols2)

qc <- as.matrix(colData(fluidigm_high)[,metadata(fluidigm_high)$which_qc])
qcpca <- prcomp(qc, scale=TRUE)

quality <- qcpca$x[,1]
detection_rate <- colSums(high>0)

data.frame(W1=zinb_norm@W[,1], W2=zinb_norm@W[,2]) %>% ggplot(aes(W1, W2)) + geom_point(aes(color=detection_rate)) + scale_colour_gradient(low="blue", high="yellow") + theme_classic()
```

Compared to PCA (of the log counts)

```{r pca_scran}
pca_norm <- prcomp(t(log1p(norm)))
plot(pca_norm$x, col=cols[bio], pch=19)
legend("bottomleft", levels(bio), fill=cols)

plot(pca_norm$x, col=cols2[cl], pch=19)
legend("topleft", levels(cl), fill=cols2)
```

Check the correlations between two zinb factors, the total numbers of reads and the total numbers of detected genes.

```{r corr_scran, echo=TRUE}
#first factor and total number of detected genes in the cell
cor(zinb_norm@W[,1], colSums(high>0),method="spearman")

#second factor and the total number of detected genes in the cell
cor(zinb_norm@W[,2], colSums(high>0),method="spearman")

#first factor and the total number of counts in the cell
cor(zinb_norm@W[,1], colSums(high),method="spearman")

#second factor and the total number of counts in the cell
cor(zinb_norm@W[,2], colSums(high),method="spearman")
```

Same for PCA

```{r corr_scran2, echo=TRUE}
#first factor and total number of detected genes in the cell
cor(pca_norm$x[,1], colSums(high>0), method="spearman")

#second factor and the total number of detected genes in the cell
cor(pca_norm$x[,2], colSums(high>0), method="spearman")


#first factor and the total number of counts in the cell
cor(pca_norm$x[,1], colSums(high), method="spearman")

#second factor and the total number of counts in the cell
cor(pca_norm$x[,2], colSums(high), method="spearman")
```

Correlation between PCA and ZINB

```{r corr_scran3, echo=TRUE}
cor(pca_norm$x[,1], zinb_norm@W[,1], method="spearman")
cor(pca_norm$x[,2], zinb_norm@W[,1], method="spearman")
cor(pca_norm$x[,1], zinb_norm@W[,2], method="spearman")
cor(pca_norm$x[,2], zinb_norm@W[,2], method="spearman")
```

## Using FQ derived offsets

```{r fq}
se <- newSeqExpressionSet(high)
se <- betweenLaneNormalization(se, which="full", offset=TRUE)
offsets <- t(offst(se))
```

```{r zinb_fq}
set.seed(35235)
print(system.time(zinb_fq <- zinbFit(high, ncores = 3, K = 2, O_mu = offsets)))
```

Plot the results with cells colored according to their biological condition.

```{r zinb_fq_plot}
plot(zinb_fq@W, col=cols[bio], pch=19, xlab="W1", ylab="W2")
legend("topleft", levels(bio), fill=cols)

plot(zinb_fq@W, col=cols2[cl], pch=19, xlab="W1", ylab="W2")
legend("topleft", levels(cl), fill=cols2)

data.frame(W1=zinb_fq@W[,1], W2=zinb_fq@W[,2]) %>% ggplot(aes(W1, W2)) + geom_point(aes(color=detection_rate)) + scale_colour_gradient(low="blue", high="yellow") + theme_classic()
```

Compared to PCA (of the log counts)

```{r pca_fq}
pca_fq <- prcomp(t(log1p(fq)))
plot(pca_fq$x, col=cols[bio], pch=19)
legend("topright", levels(bio), fill=cols)

plot(pca_fq$x, col=cols2[cl], pch=19)
legend("topright", levels(cl), fill=cols2)
```

Check the correlations between two zinb factors, the total numbers of reads and the total numbers of detected genes.

```{r corr_fq, echo=TRUE}
#first factor and total number of detected genes in the cell
cor(zinb_fq@W[,1], colSums(high>0),method="spearman")

#second factor and the total number of detected genes in the cell
cor(zinb_fq@W[,2], colSums(high>0),method="spearman")

#first factor and the total number of counts in the cell
cor(zinb_fq@W[,1], colSums(high),method="spearman")

#second factor and the total number of counts in the cell
cor(zinb_fq@W[,2], colSums(high),method="spearman")
```

Same for PCA

```{r corr_fq2, echo=TRUE}
#first factor and total number of detected genes in the cell
cor(pca_fq$x[,1], colSums(high>0), method="spearman")

#second factor and the total number of detected genes in the cell
cor(pca_fq$x[,2], colSums(high>0), method="spearman")


#first factor and the total number of counts in the cell
cor(pca_fq$x[,1], colSums(high), method="spearman")

#second factor and the total number of counts in the cell
cor(pca_fq$x[,2], colSums(high), method="spearman")
```

Correlation between PCA and ZINB

```{r corr_fq3, echo=TRUE}
cor(pca_fq$x[,1], zinb_fq@W[,1], method="spearman")
cor(pca_fq$x[,2], zinb_fq@W[,1], method="spearman")
cor(pca_fq$x[,1], zinb_fq@W[,2], method="spearman")
cor(pca_fq$x[,2], zinb_fq@W[,2], method="spearman")
```

```{r write_high}
## write matrices to file to feed to ZIFA in python
write.csv(log1p(high), file="logcounts_high.csv")
write.csv(log1p(norm), file="logcounts_high_scran.csv")
```

# Low coverage data

Select low coverage cells, filter out the genes that do not have at least 10 counts in at least 10 cells.

```{r datain_low}
fluidigm_low <- fluidigm[,which(colData(fluidigm)$Coverage_Type=="Low")]
filter <- apply(assay(fluidigm_low)>10, 1, sum)>=10
```

Number of retained genes:
```{r}
print(sum(filter))
```

## No normalization

Fit a zinb model on the low coverage data (no normalization).

```{r filtering_low}
fluidigm_low <- fluidigm_low[filter,]
low <- assay(fluidigm_low)
```

```{r zinb_low}
set.seed(654)
print(system.time(zinb_low <- zinbFit(low, ncores = 3, K = 2)))
```

Plot the results with cells colored according to their biological condition.

```{r zinb_low_plot}
bio <- as.factor(colData(fluidigm_low)$Biological_Condition)
cl <- as.factor(colData(fluidigm_low)$Cluster2)

plot(zinb_low@W, col=cols[bio], pch=19, xlab="W1", ylab="W2")
legend("topleft", levels(bio), fill=cols)

plot(zinb_low@W, col=cols2[cl], pch=19, xlab="W1", ylab="W2")
legend("topleft", levels(cl), fill=cols2)
```

Compared to PCA (of the log counts)

```{r pca_low}
pca <- prcomp(t(log1p(low)))
plot(pca$x, col=cols[bio], pch=19)
legend("topleft", levels(bio), fill=cols)

plot(pca$x, col=cols2[cl], pch=19)
legend("topleft", levels(cl), fill=cols2)
```

Check the correlations between two zinb factors, the total numbers of reads and the total numbers of detected genes.

```{r corr_low, echo=TRUE}
#first factor and total number of detected genes in the cell
cor(zinb_low@W[,1], colSums(low>0),method="spearman")

#second factor and the total number of detected genes in the cell
cor(zinb_low@W[,2], colSums(low>0),method="spearman")


#first factor and the total number of counts in the cell
cor(zinb_low@W[,1], colSums(low),method="spearman")

#second factor and the total number of counts in the cell
cor(zinb_low@W[,2], colSums(low),method="spearman")
```

Same for PCA

```{r corr2_low, echo=TRUE}
#first factor and total number of detected genes in the cell
cor(pca$x[,1], colSums(low>0), method="spearman")

#second factor and the total number of detected genes in the cell
cor(pca$x[,2], colSums(low>0), method="spearman")


#first factor and the total number of counts in the cell
cor(pca$x[,1], colSums(low), method="spearman")

#second factor and the total number of counts in the cell
cor(pca$x[,2], colSums(low), method="spearman")
```

Correlation between PCA and ZINB

```{r corr3_low, echo=TRUE}
cor(pca$x[,1], zinb_low@W[,1], method="spearman")
cor(pca$x[,2], zinb_low@W[,1], method="spearman")
cor(pca$x[,1], zinb_low@W[,2], method="spearman")
cor(pca$x[,2], zinb_low@W[,2], method="spearman")
```

## Using scran size factors

```{r scran_low}
sce <- newSCESet(countData=data.frame(low))
sce <- computeSumFactors(sce, sizes=c(10, 20, 30))

sf <- sizeFactors(sce)

norm <- exprs(convertTo(sce, type="monocle"))

plotRLE(low, outline=FALSE, col=cols[bio], main="Unnormalized counts")
plotRLE(norm, outline=FALSE, col=cols[bio], main="SCRAN normalization")
```

```{r zinb_scran_low}
set.seed(3525)
offsets <- matrix(rep(sf, NROW(low)), ncol=NROW(low), nrow=NCOL(low))
print(system.time(zinb_norm <- zinbFit(low, ncores = 3, K = 2, O_mu = offsets)))
```

Plot the results with cells colored according to their biological condition.

```{r zinb_scran_low_plot}
plot(zinb_norm@W, col=cols[bio], pch=19, xlab="W1", ylab="W2")
legend("topleft", levels(bio), fill=cols)

plot(zinb_norm@W, col=cols2[cl], pch=19, xlab="W1", ylab="W2")
legend("topleft", levels(cl), fill=cols2)

qc <- as.matrix(colData(fluidigm_low)[,metadata(fluidigm_low)$which_qc])
qcpca <- prcomp(qc, scale=TRUE)

quality <- qcpca$x[,1]
detection_rate <- colSums(low>0)

data.frame(W1=zinb_norm@W[,1], W2=zinb_norm@W[,2]) %>% ggplot(aes(W1, W2)) + geom_point(aes(color=detection_rate)) + scale_colour_gradient(low="blue", high="yellow") + theme_classic()
```

Compared to PCA (of the log counts)

```{r pca_low_scran}
pca_norm <- prcomp(t(log1p(norm)))
plot(pca_norm$x, col=cols[bio], pch=19)
legend("bottomleft", levels(bio), fill=cols)

plot(pca_norm$x, col=cols2[cl], pch=19)
legend("topleft", levels(cl), fill=cols2)
```

Check the correlations between two zinb factors, the total numbers of reads and the total numbers of detected genes.

```{r corr_scran_low, echo=TRUE}
#first factor and total number of detected genes in the cell
cor(zinb_norm@W[,1], colSums(low>0),method="spearman")

#second factor and the total number of detected genes in the cell
cor(zinb_norm@W[,2], colSums(low>0),method="spearman")

#first factor and the total number of counts in the cell
cor(zinb_norm@W[,1], colSums(low),method="spearman")

#second factor and the total number of counts in the cell
cor(zinb_norm@W[,2], colSums(low),method="spearman")
```

Same for PCA

```{r corr_scran2_low, echo=TRUE}
#first factor and total number of detected genes in the cell
cor(pca_norm$x[,1], colSums(low>0), method="spearman")

#second factor and the total number of detected genes in the cell
cor(pca_norm$x[,2], colSums(low>0), method="spearman")


#first factor and the total number of counts in the cell
cor(pca_norm$x[,1], colSums(low), method="spearman")

#second factor and the total number of counts in the cell
cor(pca_norm$x[,2], colSums(low), method="spearman")
```

Correlation between PCA and ZINB

```{r corr_scran3_low, echo=TRUE}
cor(pca_norm$x[,1], zinb_norm@W[,1], method="spearman")
cor(pca_norm$x[,2], zinb_norm@W[,1], method="spearman")
cor(pca_norm$x[,1], zinb_norm@W[,2], method="spearman")
cor(pca_norm$x[,2], zinb_norm@W[,2], method="spearman")
```

## Include detection rate as covariates

```{r zinb_det}
x <- model.matrix(~scale(detection_rate))
set.seed(9948)
print(system.time(zinb_norm <- zinbFit(low, ncores = 3, K = 2, X = x, which_X_mu=1:2, which_X_pi=1L)))
```

```{r zinb_det_low_plot}
plot(zinb_norm@W, col=cols[bio], pch=19, xlab="W1", ylab="W2")
legend("topleft", levels(bio), fill=cols)

plot(zinb_norm@W, col=cols2[cl], pch=19, xlab="W1", ylab="W2")
legend("topleft", levels(cl), fill=cols2)

data.frame(W1=zinb_norm@W[,1], W2=zinb_norm@W[,2]) %>% ggplot(aes(W1, W2)) + geom_point(aes(color=detection_rate)) + scale_colour_gradient(low="blue", high="yellow") + theme_classic()
```

```{r write_low}
## write matrices to file to feed to ZIFA in python
write.csv(log1p(low), file="logcounts_low.csv")
write.csv(log1p(norm), file="logcounts_low_scran.csv")
write.csv(log1p(low[1:5, 1:3]), file="logcounts_toy.csv")
```

# ZIFA (low coverage, unnormalized data)

```{r zifa}
zifa_res <- read.csv("zifa_low.csv", header=FALSE)

plot(zifa_res, col=cols[bio], pch=19, xlab="W1", ylab="W2")
legend("topleft", levels(bio), fill=cols)
```

# Adding $V_\pi$

```{r gc}
library(biomaRt)
mart <- useMart("ensembl")
mart <- useDataset("hsapiens_gene_ensembl", mart = mart)
attrs <- c("hgnc_symbol", "entrezgene")
bm <- getBM(attributes=attrs, mart = mart)
bm <- bm[match(rownames(low), bm[,1]),]
bm <- na.omit(bm)
low <- low[bm[,1],]

gene_info <- getGeneLengthAndGCContent(as.character(bm[,2]), "hsa", mode="org.db")
rownames(gene_info) <- bm[,1]

gene_info <- na.omit(gene_info)
low <- low[rownames(gene_info),]
```

NB: currently, there is no way to have no columns of X or V in either $\mu$ or $\pi$. We should let the user specify NULL?

```{r zinb_gc}
V <- cbind(rep(0, NROW(low)), gene_info)
print(system.time(zinb_gc <- zinbFit(low, ncores = 3, K = 2, V = V, which_V_mu=1L, which_V_pi=2:3)))
```

```{r zinb_gc_plot}
plot(zinb_gc@W, col=cols[bio], pch=19, xlab="W1", ylab="W2")
legend("bottomright", levels(bio), fill=cols)

plot(zinb_gc@W, col=cols2[cl], pch=19, xlab="W1", ylab="W2")
legend("bottomright", levels(cl), fill=cols2)
```

# Removing V intercept

```{r zinb_noV}
print(system.time(zinb_nov <- zinbFit(low, ncores = 3, K = 2, V=matrix(0, ncol=1, nrow=NROW(low)))))
```

```{r zinb_nov_plot}
plot(zinb_nov@W, col=cols[bio], pch=19, xlab="W1", ylab="W2")
legend("bottomright", levels(bio), fill=cols)

plot(zinb_nov@W, col=cols2[cl], pch=19, xlab="W1", ylab="W2")
legend("bottomright", levels(cl), fill=cols2)
```

## Keeping it for $\pi$

```{r zinb_v}
V <- cbind(rep(0, NROW(low)), rep(1, NROW(low)))
print(system.time(zinb_v <- zinbFit(low, ncores = 3, K = 2, V=V, which_V_mu=1L, which_V_pi=2L)))
```

```{r zinb_v_plot}
plot(zinb_v@W, col=cols[bio], pch=19, xlab="W1", ylab="W2")
legend("bottomleft", levels(bio), fill=cols)
```

## Keeping it for $\mu$

```{r zinb_v2}
V <- cbind(rep(0, NROW(low)), rep(1, NROW(low)))
print(system.time(zinb_v2 <- zinbFit(low, ncores = 3, K = 2, V=V, which_V_mu=2L, which_V_pi=1L)))
```

```{r zinb_v2_plot}
plot(zinb_v2@W, col=cols[bio], pch=19, xlab="W1", ylab="W2")
legend("bottomleft", levels(bio), fill=cols)
```

```{r zinb_vx}
V <- cbind(rep(0, NROW(low)), rep(1, NROW(low)))
X <- cbind(rep(0, NCOL(low)), rep(1, NCOL(low)))
print(system.time(zinb_vx <- zinbFit(low, ncores = 3, K = 2, V=V, X=X, which_V_mu=1L, which_V_pi=2L, which_X_mu=2L, which_X_pi=1L)))
```

```{r zinb_vx_plot}
plot(zinb_vx@W, col=cols[bio], pch=19, xlab="W1", ylab="W2")
legend("bottomleft", levels(bio), fill=cols)
```
