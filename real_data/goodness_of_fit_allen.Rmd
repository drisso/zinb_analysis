---
title: "Goodness-of-fit Allen"
author: "Fanny Perraudeau"
date: "03/24/2017"
output: 
  html_document: 
  fig_height: 10
fig_width: 10
toc: yes
code_folding: hide
toc_float: yes
---
```{r options, echo=FALSE, results="hide",message=FALSE, error=FALSE, include=FALSE, autodep=TRUE}
knitr::opts_chunk$set(fig.align="center", cache=TRUE, error=FALSE, message=FALSE, warning=TRUE, fig.width=6, fig.height=6)
library(zinbwave)
library(cluster)
library(RColorBrewer)
library(ggplot2)
library(reshape)
library(EDASeq)
library(edgeR)
library(dplyr)
library(DESeq2)
library(cowplot)
library(matrixStats)
library(scRNAseq)
library(MAST)
library(BiocParallel)
library(doParallel)
mycol = c(brewer.pal(11,"RdYlGn")[c(8:11, 1:4)], brewer.pal(11,"RdYlBu")[8:11])
```

```{r parallel}
NCORES = 2
mysystem = Sys.info()[['sysname']]
if (mysystem == 'Darwin'){
  registerDoParallel(NCORES)
  register(DoparParam())
}else if (mysystem == 'Linux'){
  register(bpstart(MulticoreParam(workers=NCORES)))
}else{
  print('Please change this to allow parallel computing')
  register(SerialParam())
}
```

```{r datain}
df = 'allen'

data("allen")
allen_core <- allen[grep("^ERCC-", rownames(allen), invert = TRUE),
                    which(colData(allen)$Core.Type=="Core")]
filter <- rowSums(assay(allen_core)>10)>=10
raw <- assay(allen_core)[filter,]
col1 <- brewer.pal(9, "Set1")
level1 <- as.factor(colData(allen_core)$driver_1_s)
colMerged <- col1[level1]

vars <- rowVars(log1p(as.matrix(raw)))
names(vars) <- rownames(raw)
vars <- sort(vars, decreasing = TRUE)
vargenes <- names(vars)[1:1000]

core <- as.matrix(raw[vargenes, ])
```

```{r zinb}
zinb <- zinbFit(core, K = 0, epsilon = 1e3, commondispersion = FALSE)
```

```{r functions}
computeExp <- function(zinbModel){
  (1 - t(getPi(zinbModel))) * t(getMu(zinbModel))
}

computeVar <- function(zinbModel){
  mu = t(getMu(zinbModel))
  pi = t(getPi(zinbModel))
  phi = exp(-getZeta(zinbModel))
  (1 - pi) * mu * (1 + mu*(phi + pi))
}

computeP0 <- function(zinbModel){
  mu = t(getMu(zinbModel))
  pi = t(getPi(zinbModel))
  phi = exp(-getZeta(zinbModel))
  pi + (1 - pi) * (1 + phi * mu) ^ (-1/phi)
}

plotMD <- function(x, y, xlim = c(0,10), ylim = c(-5, 5),
                   main = 'ZINB: MD-plot estimated vs. observed mean count, log scale'){
  mm = .5*(x + y)
  dd = x - y
  smoothScatter(mm, dd, xlim = xlim, ylim = ylim, xlab = 'Mean', ylab = 'Difference',
                main = main)
  abline(h = 0, col = 'gray')
  fit = loess(dd ~ mm)
  xpred = seq(0, 10, .1)
  pred = predict(fit, xpred)
  lines(xpred, pred, col = 'red', type = 'l', lwd=2)
}

fitNB <- function(counts){
  set = newSeqExpressionSet(counts)
  fq = EDASeq::betweenLaneNormalization(set, which = "full", offset = T)
  disp = estimateDisp(counts(fq), offset = -offst(fq)) 
  fit = glmFit(counts(fq), dispersion = disp$tagwise.dispersion, offset = -offst(fq))
  list(fitted = fit$fitted.values, disp = disp$tagwise.dispersion)
}
```

```{r nbzinb}
# zinb
zz = zinb
zinbEY = log(rowMeans(computeExp(zz)))
zinbPY0 = rowMeans(computeP0(zz))
# observed
logAveCount = log(rowMeans(core))
prop0 = rowMeans(core == 0)
# edgeR
nb = fitNB(core)
nbEY = log(rowMeans(nb$fitted))
nbPY0 = rowMeans((1 + nb$fitted * nb$disp)^(-1/nb$disp))
```


```{r mast}
#input of MAST = log2(TPM+1)
invlogit = function(x) 1/(1 + exp(-x))
tpm <- core*1e6/colSums(core)
tpm <- log2(tpm+1)
sca = FromMatrix(tpm)

cdr2 <-colSums(assay(sca)>0)
colData(sca)$cngeneson <- scale(cdr2)

# Adaptive thresholding as in MAIT analysis MAST vignette
thres <- thresholdSCRNACountMatrix(assay(sca), nbins = 20,
                                   min_per_bin = 30)
par(mfrow=c(5,4))
plot(thres)
assays(sca) <- list(thresh=thres$counts_threshold, tpm=assay(sca))
freq_expressed <- 0.2
expressed_genes <- freq(sca) > freq_expressed
sca <- sca[expressed_genes,] 
# for our dataset, no gene were filtered out (we kept 1000 most variable genes)

fit <- zlm(~ cngeneson, sca)
X = model.matrix(~ colData(sca)$cngeneson)
P_z_0 = 1-invlogit(coef(fit, 'D') %*% t(X))
mean_gaussian = coef(fit, 'C') %*% t(X)
var_gaussian = fit@dispersion[,'C']
EY =  (1-P_z_0)  * mean_gaussian
hurdleEY = rowMeans(EY)
hurdlePY0 = rowMeans(P_z_0)
```

```{r}
safeContrastDP <- function(contrast, Coef) uncomplexify(complexifyNA(Coef) %*% t(contrast))
complexifyNA <- function(x){
    x[is.na(x)] <- 0+1i
    x
}

uncomplexify <- function(x){
    x[abs(Im(x))>.Machine$double.eps] <- NA
    nx <- as.numeric(x)
    dim(nx) <- dim(x)
    nx
}

modelmatrix = fit@LMlike@modelMatrix
C = coef(fit,"C")[,colnames(modelmatrix)]
predC = safeContrastDP(modelmatrix, C)
pmast=uncomplexify(complexifyNA(C) %*% t(modelmatrix))
pmast[1:3,1:3]

mean_gaussian[1:3,1:3]

CJ(sample = rownames(modelmatrix), primerid = rownames(C), sorted=FALSE)
```

MD-plot estimated vs. observed mean count, log scale
```{r plot1}
pdf(sprintf('../paper/6680489mtyrjx/gof_mu_%s.pdf', df), width = 10, height = 5)
par(mfrow=c(1,2))
xlim =  c(2,9.5)
ylim = c(-1, 3)
plotMD(zinbEY, logAveCount, xlim = xlim, ylim = ylim, main = 'ZINB, ZINB-WaVE')
plotMD(nbEY, logAveCount, xlim = xlim, ylim = ylim, main = 'NB, edgeR')
dev.off()
```

MD-plot estimated vs. observed zero probability
```{r plot2}
pdf(sprintf('../paper/6680489mtyrjx/gof_pi_%s.pdf', df), width = 10, height = 5)
par(mfrow = c(1, 2))
plotMD(zinbPY0, prop0, xlim = c(0, .8), ylim = c(-.2, .1), main = 'ZINB, ZINB-WaVE')
plotMD(nbPY0, prop0, xlim = c(0, .8), ylim = c(-.2, .1), main = 'NB, edgeR')
dev.off()
```

Estimated dispersion versus observed zero probability
```{r plot3}
pdf(sprintf('../paper/6680489mtyrjx/gof_disp_%s.pdf', df), width = 10, height = 5)
par(mfrow = c(1,2))
xpred = seq(0, 1, .05)
fitzinb = loess(exp(-zz@zeta) ~ rowMeans(core == 0))
predzinb = predict(fitzinb, xpred)
fitnb = loess(nb$disp ~ rowMeans(core == 0))
prednb = predict(fitnb, xpred)
fithurdle = loess(var_gaussian ~ rowMeans(core == 0))
predhurdle = predict(fithurdle, xpred)

smoothScatter(rowMeans(core == 0), exp(-zz@zeta),
              xlab = 'Observed zero probability',ylim = c(0, 15),
              ylab = 'Estimated dispersion',xlim = c(0,1), 
              main = 'ZINB, ZINB-WaVE')
lines(xpred, predzinb, col = 'red', type = 'l', lwd=2)

smoothScatter(rowMeans(core == 0), nb$disp,
              xlab = 'Observed zero probability',ylim = c(0, 15),
              ylab = 'Estimated dispersion',xlim = c(0,1), 
              main = 'NB, edgeR')
lines(xpred, prednb, col = 'red', type = 'l', lwd=2)
dev.off()
```

```{r}
pdf('../paper/6680489mtyrjx/gof_mast.pdf', width = 10, height = 5)
par(mfrow = c(1, 3))
plotMD(hurdleEY, rowMeans(tpm), main = 'Mean log2(TPM+1)', ylim = c(-2,2),
       xlim=c(0,10))
plotMD(hurdlePY0, prop0, xlim = c(0, 1), main = 'Zero probability', ylim = c(-1,1))
smoothScatter(rowMeans(core == 0), var_gaussian,
              xlab = 'Observed zero probability',ylim = c(0, 7),
              ylab = 'Estimated gaussian variance',xlim = c(0,1), 
              main = 'Gaussian variance')
lines(xpred, predhurdle, col = 'red', type = 'l', lwd=2)
par(mfrow = c(1, 1))
dev.off()
```
# sessionInfo

```{r}
sessionInfo()
```
