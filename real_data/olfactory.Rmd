---
title: "Analysis of the olfactory data"
author: "Davide Risso"
date: "10/21/2016"
output: 
  html_document: 
    fig_height: 7
    fig_width: 7
    toc: yes
    code_folding: hide
    toc_float: yes
---

```{r options, echo=FALSE, results="hide",mesasge=FALSE, error=FALSE, include=FALSE, autodep=TRUE}
knitr::opts_chunk$set(fig.align="center", cache=TRUE, error=FALSE, message=FALSE, warning=TRUE)
library(SummarizedExperiment)
library(scRNAseq)
library(zinb)
library(ggplot2)
library(magrittr)
library(matrixStats)
library(Rtsne)
library(scone)
library(RColorBrewer)
set.seed(20)
```

## TL;DR

Applying our zero-inflated model to the olfactory data.

## Unnormalized data

We select only the cells that pass QC, color coded by the experimental time point. I will focus on the top 1,000 most variable genes. Note that the data are not public, hence it should not work other than on Davide's computer.

```{r datain}
load("Expt4c2b_filtdata.Rda")
load("E4c2b_slingshot_wsforkelly.RData")
```

To speed up the computations, I will focus on the top 1,000 most variable genes.

```{r filtering}
names(batch) <- colnames(counts)

counts <- counts[,names(clus.labels)]
batch <- droplevels(batch[names(clus.labels)])
qc <- qc[names(clus.labels),]

vars <- rowVars(log1p(counts))
names(vars) <- rownames(counts)
vars <- sort(vars, decreasing = TRUE)
core <- counts[names(vars)[1:1000],]
```

## PCA

First, let's look at PCA (of the log counts) for reference.

```{r pca}
par(mfrow=c(1, 2))
detection_rate <- colSums(core>0)
coverage <- colSums(core)
colMerged <- cc_rev[clus.labels]

pca <- prcomp(t(log1p(core)))
plot(pca$x, col=colMerged, pch=19, main="PCA of log-counts, centered not scaled")

fq <- EDASeq::betweenLaneNormalization(counts, which="full")

pcafq <- prcomp(t(log1p(fq)))
plot(pcafq$x, col=colMerged, pch=19, main="PCA of FQ log-counts, centered not scaled")
```

The first plot is the unnormalized data and the second plot is after full-quantile normalization, which is what Russell and Diya used for the paper.

They found that to fully explain the differences between clusters, we need three dimensions.

```{r pca3}
pairs(pcafq$x[,1:3], col=colMerged, pch=19, main="PCA of FQ log-counts, centered not scaled")
```

```{r pca_cor}
df <- data.frame(PC1=pcafq$x[,1], PC2=pcafq$x[,2], detection_rate=detection_rate, coverage=coverage)
pairs(df, pch=19, col=colMerged)

print(cor(df, method="spearman"))
```

Even after full-quantile normalization, there is some residual correlation between PC2 and detection rate.

```{r pca_tosave}
library(scone)
library(rARPACK)
fastpca <- function(expr, scale=FALSE) {
  svd_raw <- svds(scale(t(expr), center=TRUE, scale=scale), k=3, nu=3, nv=0)
  pc_raw <- svd_raw$u %*% diag(svd_raw$d[1:3])
  return(pc_raw)
}

raw <- as.matrix(counts)
totalcount = function (ei)
{
  sums = colSums(ei)
  eo = t(t(ei)*mean(sums)/sums)
  return(eo)
}

tc <- totalcount(raw)
fq <- FQT_FN(raw)
tmm <- TMM_FN(raw)

vargenes <- rownames(core)

pc_raw <- fastpca(log1p(raw[vargenes,]))
pc_tc <- fastpca(log1p(tc[vargenes,]))
pc_fq <- fastpca(log1p(fq[vargenes,]))
pc_tmm <- fastpca(log1p(tmm[vargenes,]))
```

```{r zifa}
wrapRzifa <- function(Y, block = TRUE, k=2){
  # wrapper R function for ZIFA.
  # md5 hashing and temporary files are used not to re-run zifa 
  # if it has already be run on this computer.
  d = digest(Y, "md5")
  tmp = paste0(tempdir(), '/', d)
  write.csv(Y, paste0(tmp, '.csv'))
  
  if (!file.exists(paste0(tmp, "_", k, '_zifa.csv'))){
    print('run ZIFA')
    bb = ifelse(block, '-b ', '')
    cmd = sprintf('python run_zifa.py -d %d %s%s.csv %s_%d_zifa.csv', k, bb, tmp, tmp, k)
    system(cmd)
  }
  read.csv(sprintf("%s_%d_zifa.csv", tmp, k), header=FALSE)
}

zifa_raw <- wrapRzifa(log1p(raw[vargenes,]), k=3)

zifa_tc <- wrapRzifa(log1p(tc[vargenes,]), k=3)

zifa_tmm <- wrapRzifa(log1p(tmm[vargenes,]), k=3)

zifa_fq <- wrapRzifa(log1p(fq[vargenes,]), k=3)
```

## ZINB

```{r zinb}
print(system.time(zinb_Vall <- zinbFit(core, ncores = 3, K = 3)))
```

```{r zinb_plot}
pairs(zinb_Vall@W, col=colMerged, pch=19, main="ZINB")
```

```{r gamma}
qcpca <- prcomp(qc, center=TRUE, scale.=TRUE)

df <- data.frame(W1=zinb_Vall@W[,1], W2=zinb_Vall@W[,2], W3=zinb_Vall@W[,3], gamma_mu = zinb_Vall@gamma_mu[1,], gamma_pi = zinb_Vall@gamma_pi[1,], detection_rate=detection_rate, coverage=coverage, quality=qcpca$x[,1])
pairs(df, pch=19, col=colMerged)

print(cor(df, method="spearman"))
```

## Accounting for quality

```{r qpca}
mod <- model.matrix(~qcpca$x[,1:5])
```

```{r zinb_three}
print(system.time(zinb_3 <- zinbFit(core, ncores = 3, K = 3, X=mod)))
```

```{r three_plot}
pairs(zinb_3@W, col=colMerged, pch=19, main="ZINB")
```

```{r three_gamma}
#total number of detected genes in the cell
df <- data.frame(W1=zinb_3@W[,1], W2=zinb_3@W[,2], W3=zinb_3@W[,3], gamma_mu = zinb_3@gamma_mu[1,], gamma_pi = zinb_3@gamma_pi[1,], detection_rate=detection_rate, coverage=coverage)
pairs(df, pch=19, col=colMerged)

print(cor(df, method="spearman"))
```

## Four dimensions

```{r zinb_four}
print(system.time(zinb_4 <- zinbFit(core, ncores = 3, K = 4)))
```

```{r four_plot}
pairs(zinb_4@W, col=colMerged, pch=19, main="ZINB")
```

```{r save, dependson="zifa"}
save(zinb_3, zinb_4, zinb_Vall, pc_tmm, pc_fq, pc_tc, pc_raw, zifa_fq, zifa_tmm, zifa_tc, zifa_raw, file="olfactory.rda")
```
