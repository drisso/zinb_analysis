---
title: "PBMC 4k clustering"
author: "Davide Risso"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: 
  html_document: 
    fig_height: 7
    fig_width: 7
    toc: yes
    code_folding: hide
    toc_float: yes
---

```{r options, include=FALSE}
knitr::opts_chunk$set(cache=TRUE, error=FALSE, message=FALSE, warning=FALSE)
```

Here, we look more carefully at clustering of the 4k PBMCs from 10X Genomics.

We will use PAM clustering with k=9 on W with three dimension and compare with
the clustering published by 10X Genomics.

We will also compare to a more similar procedure that uses PAM with k=9 on the top
3 and 50 PCs.

```{r original}
tsne_coords <- read.csv("tenx_pbmc4k/projection.csv", row.names=1)
clusters <- read.csv("tenx_pbmc4k/clusters.csv")
cl <- clusters[,2]
names(cl) <- clusters[,1]
table(cl)
dim(clusters)
dim(tsne_coords)

stopifnot(all(names(cl)==rownames(tsne_coords)))

tsne_coords$cluster <- as.factor(cl)

pal <- clusterExperiment::bigPalette
plot(tsne_coords[,1:2], pch=19, col=pal[cl])
```

# ZINBWAVE + PAM

```{r zinb}
library(cluster)
library(zinbwave)
load("tenx_pbmc4k/zinb_res.rda")
load("tenx_pbmc4k/zinb_gcc.rda")

W <- getW(zinb_res)
plot(W, pch=19, col=pal[cl])
pairs(W, pch=19, col=pal[cl])

Wgcc <- getW(zinb_gcc)
plot(Wgcc, pch=19, col=pal[cl])
pairs(Wgcc, pch=19, col=pal[cl])
```

```{r pam}
d <- dist(W)
pam_res <- pam(d, k=9)
pam_cl <- pam_res$clustering
table(pam_cl)

table(pam_cl, cl)

plot(W, pch=19, col=pal[pam_cl])
pairs(W, pch=19, col=pal[pam_cl])

plot(tsne_coords[,1:2], pch=19, col=pal[pam_cl])

d <- dist(Wgcc)
pam_res <- pam(d, k=9)
pam_clg <- pam_res$clustering
table(pam_clg)

table(pam_clg, cl)
table(pam_clg, pam_cl)

plot(Wgcc, pch=19, col=pal[pam_clg])
pairs(Wgcc, pch=19, col=pal[pam_clg])

plot(tsne_coords[,1:2], pch=19, col=pal[pam_clg])
```

# PCA + PAM

```{r pca}
load("tenx_pbmc4k/pca_res.rda")
plot(pc_tc, pch=19, col=pal[cl])
```

## First 3 PC

```{r pam2}
d <- dist(pc_tc[,1:3])
pam_res <- pam(d, k=9)
pam_cl2 <- pam_res$clustering
table(pam_cl2)

table(pam_cl2, cl)
table(pam_cl2, pam_cl)

plot(pc_tc, pch=19, col=pal[pam_cl2])
plot(pc_tc, pch=19, col=pal[pam_cl])

plot(W, pch=19, col=pal[pam_cl])
plot(W, pch=19, col=pal[pam_cl2])
```

## First 50 PC

```{r pam3}
d <- dist(pc_tc)
pam_res <- pam(d, k=9)
pam_cl3 <- pam_res$clustering
table(pam_cl3)

table(pam_cl3, cl)
table(pam_cl3, pam_cl)
table(pam_cl3, pam_cl2)

plot(pc_tc, pch=19, col=pal[pam_cl3])

plot(W, pch=19, col=pal[pam_cl3])
```

# Seurat

It's hard to interpret the results of PAM. Since the original clustering was done with Seurat,
we can redo the same clustering after zinbwave rather than PCA.

## Recommended Seurat analysis

```{r seurat}
library(Seurat)
library(dplyr)
library(Matrix)

pbmc.data <- Read10X("tenx_pbmc4k/outs/filtered_gene_bc_matrices/GRCh38/")
pbmc <- new("seurat", raw.data = pbmc.data)

## Keep all genes expressed in >= 3 cells, keep all cells with >= 200 genes
## Perform log-normalization, first scaling each cell to a total of 1e4 molecules (as in Macosko et al. Cell 2015)
pbmc <- Setup(pbmc, min.cells = 3, min.genes = 200, do.logNormalize = T, total.expr = 1e4, project = "10X_PBMC")
mito.genes <- grep("^MT-", rownames(pbmc@data), value = T)
percent.mito <- colSums(expm1(pbmc@data[mito.genes, ]))/colSums(expm1(pbmc@data))
pbmc <- AddMetaData(pbmc, percent.mito, "percent.mito")
VlnPlot(pbmc, c("nGene", "nUMI", "percent.mito"), nCol = 3)

GenePlot(pbmc, "nUMI", "percent.mito")
GenePlot(pbmc, "nUMI", "nGene")

# filter out cells that have unique gene counts over 2,500 (why?)
pbmc <- SubsetData(pbmc, subset.name = "nGene", accept.high = 2500)
pbmc <- SubsetData(pbmc, subset.name = "percent.mito", accept.high = 0.05)

#regress out unwanted sources of variation... (extensive normalization)
pbmc <- RegressOut(pbmc, latent.vars = c("nUMI", "percent.mito"))

#identify high variable genes
pbmc <- MeanVarPlot(pbmc ,fxn.x = expMean, fxn.y = logVarDivMean, x.low.cutoff = 0.0125, x.high.cutoff = 3, y.cutoff = 0.5, do.contour = F)

## PCA -- note that it uses 1631 most variable genes!
pbmc <- PCA(pbmc, pc.genes = pbmc@var.genes, do.print = TRUE, pcs.print = 5, genes.print = 5)
pbmc <- ProjectPCA(pbmc)

VizPCA(pbmc, 1:2)
PCAPlot(pbmc, 1, 2)

PCHeatmap(pbmc, pc.use = 1, cells.use = 100, do.balanced = TRUE)

PCHeatmap(pbmc, pc.use = 1:12, cells.use = 500, do.balanced = TRUE, label.columns = FALSE, use.full = FALSE)

## Find clusters (with 10 PCs)
pbmc <- FindClusters(pbmc, pc.use = 1:10, resolution = 0.6, print.output = 0, save.SNN = T)

table(pbmc@ident, cl[paste0(names(pbmc@ident), "-1")])
```

This seems to be the recomended way to do clustering by 10x genomics, but the results are quite
different from what they have in the website.

Let's visualize the new data and clusters.

```{r save_seurat}
pbmc <- RunTSNE(pbmc, dims.use = 1:10, do.fast = T)
TSNEPlot(pbmc)
save(pbmc, file="tenx_pbmc4k/seurat.rda")
```

```{r markers}
pbmc.markers <- FindAllMarkers(pbmc, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
pbmc.markers %>% group_by(cluster) %>% top_n(2, avg_diff) %>% pull(gene)

FeaturePlot(pbmc, c("MS4A1", "GNLY","CD3E","CD14","FCER1A","FCGR3A", "LYZ", "PPBP", "CD8A"),cols.use = c("grey","blue"))

FeaturePlot(pbmc, c("CCL5", "S100A8","IL7R","CD8B","LEF1","TCL1A", "CCR7", "IGLC2", "GNLY", "LST1", "JCHAIN", "GZMB"),cols.use = c("grey","blue"))

pbmc.markers %>% group_by(cluster) %>% top_n(10, avg_diff) -> top10
# setting slim.col.label to TRUE will print just the cluster IDS instead of every cell name
DoHeatmap(pbmc, genes.use = top10$gene, order.by.ident = TRUE, slim.col.label = TRUE, remove.key = TRUE)
```

## Seurat on unfiltered, unnormalized data

We can repeat the pipeline, but without normalization and without the cell filtering.

```{r seurat2}
library(Seurat)
library(dplyr)
library(Matrix)

pbmc.data <- Read10X("tenx_pbmc4k/outs/filtered_gene_bc_matrices/GRCh38/")
pbmc <- new("seurat", raw.data = pbmc.data)

## Keep all genes expressed in >= 3 cells
## Perform log-normalization, first scaling each cell to a total of 1e4 molecules (as in Macosko et al. Cell 2015)
pbmc <- Setup(pbmc, min.cells = 3, do.logNormalize = T, total.expr = 1e4, project = "10X_PBMC")

#identify high variable genes
pbmc <- MeanVarPlot(pbmc ,fxn.x = expMean, fxn.y = logVarDivMean, x.low.cutoff = 0.0125, x.high.cutoff = 3, y.cutoff = 0.5, do.contour = F)

## PCA -- note that it uses 1631 most variable genes!
pbmc <- PCA(pbmc, pc.genes = pbmc@var.genes, do.print = TRUE, pcs.print = 5, genes.print = 5)
pbmc <- ProjectPCA(pbmc)

VizPCA(pbmc, 1:2)
PCAPlot(pbmc, 1, 2)

PCHeatmap(pbmc, pc.use = 1, cells.use = 100, do.balanced = TRUE)

PCHeatmap(pbmc, pc.use = 1:12, cells.use = 500, do.balanced = TRUE, label.columns = FALSE, use.full = FALSE)

## Find clusters (with 10 PCs)
pbmc <- FindClusters(pbmc, pc.use = 1:40, resolution = 1.2, print.output = 0, save.SNN = T)

table(pbmc@ident, cl[paste0(names(pbmc@ident), "-1")])
```

Again, the results are not the same as in the website.

Let's visualize the new data and clusters.

```{r save_seurat2}
pbmc <- RunTSNE(pbmc, dims.use = 1:40, do.fast = T)
TSNEPlot(pbmc)
save(pbmc, file="tenx_pbmc4k/seurat_no_norm.rda")
```

```{r markers2}
pbmc.markers <- FindAllMarkers(pbmc, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
pbmc.markers %>% group_by(cluster) %>% top_n(1, avg_diff) %>% pull(gene) -> gene_list

FeaturePlot(pbmc, gene_list, cols.use = c("grey","blue"))

pbmc.markers %>% group_by(cluster) %>% top_n(10, avg_diff) -> top10
# setting slim.col.label to TRUE will print just the cluster IDS instead of every cell name
DoHeatmap(pbmc, genes.use = top10$gene, order.by.ident = TRUE, slim.col.label = TRUE, remove.key = TRUE)
```

## Suerat clustering on ZINB-WAVE projection

Hopefully, we can just hack the seurat function for knn clustering.

```{r seurat_zinb}
pbmc <- new("seurat", raw.data = pbmc.data)
pbmc <- Setup(pbmc, min.cells = 1, min.genes = 1, do.logNormalize = FALSE, do.scale=FALSE,
              do.center = FALSE, project = "10X_PBMC")

## Build SNN
k.param = 10
k.scale = 10
n.cells = 4352
data.use <- getW(zinb_gcc)
my.knn <- FNN::get.knn(as.matrix(data.use), k = min(k.scale * k.param, n.cells - 1))
nn.ranked <- cbind(1:n.cells, my.knn$nn.index[, 1:(k.param-1)])
nn.large <- my.knn$nn.index

w <- Seurat:::CalcSNNDense(pbmc, n.cells, nn.large, nn.ranked, prune.SNN = 1/15, print.output = FALSE)
pbmc@snn.k <- k.param
pbmc@snn.dense <- w
pbmc@snn.sparse <- sparseMatrix(1, 1, x = 1)

## Run modularity clustering
SNN.use <- pbmc@snn.dense
resolution <- 0.2
pbmc <- Seurat:::RunModularityClustering(pbmc, SNN.use, modularity = 1, r = resolution,
                               algorithm = 1, n.start = 100, n.iter = 10, random.seed = 0,
                               print.output = FALSE, temp.file.location = NULL)
pbmc <- Seurat:::GroupSingletons(pbmc, SNN.use)
name <- paste("res.", resolution, sep = "")
pbmc <- StashIdent(pbmc, name)

stopifnot(all(names(cl) == paste0(names(pbmc@ident), "-1")))
z_cl <- pbmc@ident
names(z_cl) <- paste0(names(pbmc@ident), "-1")

table(z_cl, cl)

pairs(data.use, pch=19, col=pal[cl])
pairs(data.use, pch=19, col=pal[z_cl])

colnames(data.use) <- paste0("W", 1:3)
rownames(data.use) <- names(z_cl)
write.table(data.frame(data.use, paste0("Cluster", z_cl)), sep="\t", quote=FALSE,
            file = "tenx_pbmc4k/zinb_gcc_clusters.txt")
```

```{r seurat_zinb2}
pbmc <- new("seurat", raw.data = pbmc.data)
pbmc <- Setup(pbmc, min.cells = 1, min.genes = 1, do.logNormalize = FALSE, do.scale=FALSE,
              do.center = FALSE, project = "10X_PBMC")

## Build SNN
k.param = 10
k.scale = 10
n.cells = 4352
data.use <- getW(zinb_res)
my.knn <- FNN::get.knn(as.matrix(data.use), k = min(k.scale * k.param, n.cells - 1))
nn.ranked <- cbind(1:n.cells, my.knn$nn.index[, 1:(k.param-1)])
nn.large <- my.knn$nn.index

w <- Seurat:::CalcSNNDense(pbmc, n.cells, nn.large, nn.ranked, prune.SNN = 1/15, print.output = FALSE)
pbmc@snn.k <- k.param
pbmc@snn.dense <- w
pbmc@snn.sparse <- sparseMatrix(1, 1, x = 1)

## Run modularity clustering
SNN.use <- pbmc@snn.dense
resolution <- 0.2
pbmc <- Seurat:::RunModularityClustering(pbmc, SNN.use, modularity = 1, r = resolution,
                               algorithm = 1, n.start = 100, n.iter = 10, random.seed = 0,
                               print.output = FALSE, temp.file.location = NULL)
pbmc <- Seurat:::GroupSingletons(pbmc, SNN.use)
name <- paste("res.", resolution, sep = "")
pbmc <- StashIdent(pbmc, name)

stopifnot(all(names(cl) == paste0(names(pbmc@ident), "-1")))
z_cl2 <- pbmc@ident
names(z_cl2) <- paste0(names(pbmc@ident), "-1")

table(z_cl2, cl)
table(z_cl2, z_cl)

plot(data.use, pch=19, col=pal[cl])
plot(data.use, pch=19, col=pal[z_cl])
plot(data.use, pch=19, col=pal[z_cl2])

colnames(data.use) <- paste0("W", 1:3)
rownames(data.use) <- names(z_cl2)
write.table(data.frame(data.use, paste0("Cluster", z_cl2)), sep="\t", quote=FALSE,
            file = "tenx_pbmc4k/zinb_res_clusters.txt")
```

# Session Info

```{r}
sessionInfo()
```
