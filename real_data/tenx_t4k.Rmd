---
title: "4k T cells from 10x genomics"
author: "Davide Risso"
date: "07/10/2017"
output: 
  html_document: 
    fig_height: 7
    fig_width: 7
    toc: yes
    code_folding: hide
    toc_float: yes
---

```{r options, echo=FALSE, results="hide",mesasge=FALSE, error=FALSE, include=FALSE, autodep=TRUE}
knitr::opts_chunk$set(fig.align="center", cache=TRUE, error=FALSE, message=FALSE, warning=TRUE)
library(zinbwave)
library(ggplot2)
library(magrittr)
library(matrixStats)
library(Rtsne)
library(RColorBrewer)
library(cowplot)

set.seed(8283)
ncores <- 7
```

Here, we apply ZINB-WaVE to the set of 4k T cells from 10x genomics. The idea is
to show scalability of the method and hopefully new biological insights.

In the 10X website, the authors performed "graph-based clustering". We will use those
labels here.

Here, I download the original UMI count matrix and run ZINB-WaVE on it. We can consider two strategies: run zinbwave with K=2 or 3 for visualization or run it with an higher K for clustering (perhaps followed by t-SNE?).

I will visualize the data using the original clustering.

# Original analysis

I've downloaded the t-sne coordinates and cluster labels of the original analysis.

```{r}
tsne_coords <- read.csv("tenx_t4k/projection.csv", row.names=1)
clusters <- read.csv("tenx_t4k/clusters.csv")
cl <- clusters[,2]
names(cl) <- clusters[,1]
table(cl)
dim(clusters)
dim(tsne_coords)

stopifnot(all(names(cl)==rownames(tsne_coords)))

tsne_coords$cluster <- as.factor(cl)
```

The data consist of 4532 cells.

```{r}
pal <- clusterExperiment::bigPalette
plot(tsne_coords[,1:2], pch=19, col=pal[cl])

ggplot(aes(TSNE.1, TSNE.2, colour=cluster), data = tsne_coords) + geom_point()
```

To see if the clusters correspond to the published clusters, we need to look at
some marker genes. To do that, I need to load the full data.

```{r}
library(cellrangerRkit)
pipestance_path <- "tenx_t4k"
if(!file.exists(paste0(pipestance_path, "/outs"))) {
  download_sample(sample_name="t_4k",sample_dir=pipestance_path,
                  host="http://cf.10xgenomics.com/samples/cell-exp/1.3.0/")
}
t4k <- load_cellranger_matrix(pipestance_path)
dim(t4k)
```

This object has the full dataset.

# ZINB-WaVE

Here, I try to run zinbwave with K=2 on the full dataset. Following the authors'
analysis and our own practice, I start with the 1000 most variable genes.

```{r}
load("~/Google Drive/SCONE_COPY/t_4k/scone_update.rda")

## select only cells that pass scone QC
keep <- which(colnames(t4k) %in% colnames(scone_obj))

use_genes <- get_nonzero_genes(t4k[, keep])
dense <- as.matrix(exprs(t4k[use_genes, keep]))

vars <- rowVars(log1p(dense))
names(vars) <- rownames(dense)
vars <- sort(vars, decreasing = TRUE)
vargenes <- names(vars)[1:1000]

dense <- dense[vargenes,]
```


```{r}
library(BiocParallel)
library(doParallel)
registerDoParallel(ncores)
register(DoparParam())
system.time(zinb_res <- zinbFit(dense, K=3))
```

```{r}
W <- getW(zinb_res)
clus <- cl[colnames(dense)]
plot(W, pch=19, col=pal[clus])
pairs(W, pch=19, col=pal[clus])
zinb_df <- data.frame(W1 = W[,1], W2 = W[,2], W3 = W[,3], Cluster=as.factor(clus))

ggplot(aes(W1, W2, colour=Cluster), data = zinb_df) + geom_point()

zinb_df$CD3D <- log1p(exprs(t4k[, keep])[which(fData(t4k)[,2] == "CD3D"),])
zinb_df$IL7R <- log1p(exprs(t4k[, keep])[which(fData(t4k)[,2] == "IL7R"),])
zinb_df$NKG7 <- log1p(exprs(t4k[, keep])[which(fData(t4k)[,2] == "NKG7"),])

ggplot(aes(W1, W2, colour=CD3D), data = zinb_df) + 
  geom_point() + scale_colour_gradient(low="blue", high="yellow")

ggplot(aes(W1, W2, colour=IL7R), data = zinb_df) + 
  geom_point() + scale_colour_gradient(low="blue", high="yellow")

ggplot(aes(W1, W2, colour=NKG7), data = zinb_df) + 
  geom_point() + scale_colour_gradient(low="blue", high="yellow")
```

```{r}
zinb_tsne <- Rtsne(W, pca = FALSE)
```

```{r}
plot(zinb_tsne$Y, pch=19, col=pal[clus])
```

```{r}
save(zinb_res, file="tenx_t4k/zinb_res.rda")
write.table(zinb_df, file="tenx_t4k/zinb_coords.txt", sep='\t', quote=FALSE, 
            row.names = TRUE)
```

## Look at data quality

```{r}
tmp <- read.table("tenx_t4k/t_4k_qc2.txt")
rownames(tmp) <- paste0(rownames(tmp), "-1")
qc <- tmp[colnames(dense),]

cors <- lapply(1:3, function(i) abs(cor(W[,i], qc)))
cors <- unlist(cors)
bars <- data.frame(AbsoluteCorrelation=cors, QC=rep(stringr::str_to_lower(colnames(qc)), 3), Dimension=as.factor(rep(1:3, each=ncol(qc))))

bars %>%
  ggplot(aes(Dimension, AbsoluteCorrelation, group=QC, fill=QC)) + 
  geom_bar(stat="identity", position='dodge') + 
  scale_fill_manual(values=pal) + ylim(0, 1) + ggtitle("Correlation bw W and QC")

library(rARPACK)
fastpca <- function(expr, scale=FALSE) {
  svd_raw <- svds(scale(t(expr), center=TRUE, scale=scale), k=3, nu=3, nv=0)
  pc_raw <- svd_raw$u %*% diag(svd_raw$d[1:3])
  return(pc_raw)
}

pc_raw <- fastpca(log1p(dense))

totalcount = function (ei)
{
  sums = colSums(ei)
  eo = t(t(ei)*mean(sums)/sums)
  return(eo)
}

tc <- totalcount(as.matrix(exprs(t4k[use_genes, keep])))
pc_tc <- fastpca(log1p(tc[rownames(dense),]))

cors <- lapply(1:3, function(i) abs(cor(pc_tc[,i], qc)))
cors <- unlist(cors)
bars <- data.frame(AbsoluteCorrelation=cors, QC=rep(stringr::str_to_lower(colnames(qc)), 3), Dimension=as.factor(rep(1:3, each=ncol(qc))))

bars %>%
  ggplot(aes(Dimension, AbsoluteCorrelation, group=QC, fill=QC)) + 
  geom_bar(stat="identity", position='dodge') + 
  scale_fill_manual(values=pal) + ylim(0, 1) + ggtitle("Correlation bw PCA and QC")
```

## Include QC in ZINB

```{r}
qcpca <- prcomp(as.matrix(qc), center=TRUE, scale=TRUE)
Xmod <- model.matrix(~qcpca$x[,1:2])
system.time(zinb_qc <- zinbFit(dense, K=3, X=Xmod))
```

```{r}
Wqc <- getW(zinb_qc)
plot(Wqc, pch=19, col=pal[clus])
pairs(Wqc, pch=19, col=pal[clus])

cors <- lapply(1:3, function(i) abs(cor(Wqc[,i], qc)))
cors <- unlist(cors)
bars <- data.frame(AbsoluteCorrelation=cors, QC=rep(stringr::str_to_lower(colnames(qc)), 3), Dimension=as.factor(rep(1:3, each=ncol(qc))))

bars %>%
  ggplot(aes(Dimension, AbsoluteCorrelation, group=QC, fill=QC)) + 
  geom_bar(stat="identity", position='dodge') + 
  scale_fill_manual(values=pal) + ylim(0, 1) + ggtitle("Correlation bw W and QC (after adjusting)")

```

## Include GC-content and length

```{r}
library(biomaRt)
mart <- useMart("ensembl")
mart <- useDataset("hsapiens_gene_ensembl", mart = mart)
bm <- getBM(attributes=c('ensembl_gene_id', 'hgnc_symbol', 'start_position',
                         'end_position', 'percentage_gene_gc_content'),
            filters = 'ensembl_gene_id',
            values = rownames(dense),
            mart = mart)

bm$length <- bm$end_position - bm$start_position
rownames(bm) <- bm$ensembl_gene_id
bm <- bm[rownames(dense),]

Vmod <- model.matrix(~log(length) + percentage_gene_gc_content, data=bm)
```

```{r}
system.time(zinb_gcc <- zinbFit(dense, K=3, V=Vmod))
```

```{r}
Wgcc <- getW(zinb_gcc)
plot(Wgcc, pch=19, col=pal[clus])
pairs(Wgcc, pch=19, col=pal[clus])

cors <- lapply(1:3, function(i) abs(cor(Wgcc[,i], qc)))
cors <- unlist(cors)
bars <- data.frame(AbsoluteCorrelation=cors, QC=rep(stringr::str_to_lower(colnames(qc)), 3), Dimension=as.factor(rep(1:3, each=ncol(qc))))

bars %>%
  ggplot(aes(Dimension, AbsoluteCorrelation, group=QC, fill=QC)) + 
  geom_bar(stat="identity", position='dodge') + 
  scale_fill_manual(values=pal) + ylim(0, 1) + ggtitle("Correlation bw W and QC (after adjusting)")
```

I think that the next step would be to perform clustering and see if we can 
reconstruct sub-populations. We could use some known t-cell signatures to show
that the clustering and/or the projection is more meaningful that, say, PCA.

# T-cell specific genes

```{r}
library(xCell)

genes <- lapply(xCell$signatures, function(x) geneIds(x))

# for each cell, get average expression of each signature
t4k_sub <- t4k[,keep]
scores <- lapply(genes, function(x) {
  idx <- intersect(rownames(dense), rownames(fData(t4k_sub))[fData(t4k_sub)[,2] %in% x])
  if(length(idx)>1) {
    return(colMeans(dense[idx,]))
  } else {
    return(NA)
  }
})
names(scores) <- names(xCell$signatures)
scores <- scores[!is.na(scores)]
scores <- simplify2array(scores)
colnames(scores) <- make.names(colnames(scores))
cors <- abs(cor(Wgcc[,1], scores))
cors <- t(cors)
head(cors[order(cors[,1], decreasing=TRUE),])

df <- data.frame(W1=Wgcc[,1], W2=Wgcc[,2], log(scores))

ggplot(aes(W1, W2, colour=CD8..Tem.BP.1), data = df) + 
  geom_point() + scale_colour_gradient(low="blue", high="yellow")

cors <- abs(cor(Wgcc[,2], log(scores)))
cors <- t(cors)
head(cors[order(cors[,1], decreasing=TRUE),])

ggplot(aes(W1, W2, colour=Monocytes.IRIS.10), data = df) + 
  geom_point() + scale_colour_gradient(low="blue", high="yellow")

cors <- abs(cor(Wgcc[,3], scores))
cors <- t(cors)
head(cors[order(cors[,1], decreasing=TRUE),])

boxplot(scores[,"CD8..Tem.BP.1"]~clus, main="CD8..Tem.BP.1")
boxplot(scores[,"Monocytes.IRIS.10"]~clus, main="Monocytes.IRIS.10")
boxplot(scores[,"NK.cells.BP.6"]~clus, main="NK.cells.BP.6")
boxplot(scores[,"Th1.cells.IRIS.3"]~clus, main="Th1.cells.IRIS.3")
boxplot(scores[,"CD4..T.cells.IRIS.8"]~clus, main="CD4..T.cells.IRIS.8")
boxplot(scores[,"CD4..naive.T.cells.IRIS.3"]~clus, main="CD4..naive.T.cells.IRIS.3")
boxplot(scores[,"Memory.B.cells.BP.1"]~clus, main="Memory.B.cells.BP.1")
boxplot(scores[,"Tregs.BP.5"]~clus, main="Tregs.BP.5")
```

# Check gene length calculations

From David's email, the definition of gene length in our QC matrix is the following.

$$
\frac{\sum_j Y_{ij} \, l_j}{\sum_j Y_{ij}}
$$

We can manually compute this quantity and see if we get the same numbers. We are
probably using a different annotation, so I'm expecting a bit of a discordance.
Also, David is using average isoform length, while I'm using the length of the longest isoform.

```{r length}
library(biomaRt)
mart <- useMart("ensembl")
mart <- useDataset("hsapiens_gene_ensembl", mart = mart)

bm2 <- getBM(attributes=c('ensembl_gene_id', 'hgnc_symbol', 'start_position',
                         'end_position', 'percentage_gene_gc_content', 'gene_biotype'),
            filters = 'ensembl_gene_id',
            values = rownames(t4k_sub)[use_genes],
            mart = mart)

bm2$length <- bm2$end_position - bm2$start_position
length <- bm2$length
names(length) <- bm2$ensembl_gene_id

t4k_exp <- t4k_sub[use_genes,]
gene_idx <- intersect(names(length), rownames(t4k_exp))
length(gene_idx)

t4k_exp <- t4k_exp[gene_idx,]
length <- length[gene_idx]

## check correlation with David's length
len <- colSums(exprs(t4k_exp) * length)/colSums(exprs(t4k_exp))
cor(log(len[rownames(qc)]), log(qc$gene_length))

## check correlation with PCA
cor(len[rownames(qc)], pc_tc[,1])
cor(qc$gene_length, pc_tc[,1])
plot(len[rownames(qc)], pc_tc[,1])
lines(lowess(len[rownames(qc)], pc_tc[,1]), col=2, lwd=2)
plot(qc$gene_length, pc_tc[,1])
lines(lowess(qc$gene_length, pc_tc[,1]), col=2, lwd=2)

## Check correlation with W
cor(len[rownames(qc)], W[,1])
cor(qc$gene_length, W[,1])
plot(len[rownames(qc)], W[,1])
lines(lowess(len[rownames(qc)], W[,1]), col=2, lwd=2)
plot(qc$gene_length, W[,1])
lines(lowess(qc$gene_length, W[,1]), col=2, lwd=2)

alpha_mu <- t(getAlpha_mu(zinb_res))
alpha_pi <- t(getAlpha_pi(zinb_res))

bins <- cut(length[rownames(dense)], breaks = quantile(length[rownames(dense)],
                                                       probs=seq(0, 1, 0.05)))
plot(alpha_mu[,1]~bins, outline=FALSE)
plot(alpha_pi[,1]~bins, outline=FALSE)

pca <- prcomp(t(log1p(tc[rownames(dense),])))
bins <- cut(length[rownames(dense)], breaks = quantile(length[rownames(dense)], probs=seq(0, 1, 0.05)))
plot(pca$rotation[,1]~bins, outline=FALSE)
```

Interestingly, the dependence does not seem to affect the loadings of the PC nor alpha.

We can do the same for GC-content.

```{r gcc}
gcc <- bm2$percentage_gene_gc_content
names(gcc) <- bm2$ensembl_gene_id

gcc <- gcc[gene_idx]

## check correlation with David's length
gc <- colSums(exprs(t4k_exp) * gcc)/colSums(exprs(t4k_exp))
cor(gc[rownames(qc)], qc$gc)
plot(gc[rownames(qc)], qc$gc)

## check correlation with PCA
cor(gc[rownames(qc)], pc_tc[,1])
cor(qc$gc, pc_tc[,1])
plot(gc[rownames(qc)], pc_tc[,1])
plot(qc$gc, pc_tc[,1])

## Check correlation with W
cor(gc[rownames(qc)], W[,1])
cor(qc$gc, W[,1])
plot(gc[rownames(qc)], W[,1])
plot(qc$gc, W[,1])
```

The results of gene length are pretty clear, but why is this the case? Do UMI counts
depend on gene length? Could this be an artifact of selecting the top 1000 variable genes?

```{r check_len}
## top 1000 genes
plot(log1p(dense[,1])~log(length[rownames(dense)]))

bins <- cut(length[rownames(dense)], breaks = quantile(length[rownames(dense)],
                                                       probs=seq(0, 1, 0.05)))
plot(log1p(dense[,1])~bins, outline=FALSE, las=2)

bins <- cut(gcc[rownames(dense)], breaks = quantile(gcc[rownames(dense)],
                                                       probs=seq(0, 1, 0.05)))
plot(log1p(dense[,1])~bins, outline=FALSE, las=2)

## all genes
xx <- log1p(exprs(t4k_exp)[exprs(t4k_exp)[,1]>0,1])

plot(xx~log(length[names(xx)]))

bins <- cut(length[names(xx)], breaks = quantile(length[names(xx)], probs=seq(0, 1, 0.05)))
plot(xx~bins, outline=FALSE, las=2)

bins <- cut(gcc[names(xx)], breaks = quantile(gcc[names(xx)], probs=seq(0, 1, 0.05)))
plot(xx~bins, outline=FALSE, las=2)
```

This is just one sample, what if we check the average expression?

```{r check_len2}
filter <- rowSums(exprs(t4k_exp)>0)>=100
filtered <- exprs(t4k_exp)[filter,]
xx <- log(rowMeans(filtered)+0.01)

plot(xx~log(length[names(xx)]))

bins <- cut(length[names(xx)], breaks = quantile(length[names(xx)], probs=seq(0, 1, 0.05)))
plot(xx~bins, outline=FALSE, las=2)

bins <- cut(gcc[names(xx)], breaks = quantile(gcc[names(xx)], probs=seq(0, 1, 0.05)))
plot(xx~bins, outline=FALSE, las=2)
```

What about dropout rates?

```{r check_len3}
xx <- rowMeans(exprs(t4k_exp)==0)

plot(xx~log(length[names(xx)]))

bins <- cut(length[names(xx)], breaks = quantile(length[names(xx)], probs=seq(0, 1, 0.05)))
plot(xx~bins, outline=FALSE, las=2, ylab="Dropout rate")

bins <- cut(gcc[names(xx)], breaks = quantile(gcc[names(xx)], probs=seq(0, 1, 0.05)))
plot(xx~bins, outline=FALSE, las=2, ylab="Dropout rate")
```

It really does seem that shorter genes tend to be more expressed than longer genes.
Also, very short and very long genes show higer dropout rates.
But this contradicts this paper: https://f1000research.com/articles/10.12688/f1000research.11290.1/doi

```{r joy, eval=FALSE}
## library(devtools)
## install_github("clauswilke/ggjoy")

library(ggplot2)
library(ggjoy)

type <- bm2$gene_biotype
names(type) <- bm2$ensembl_gene_id

boxplot(log(length[names(xx)])~type[names(xx)], las=2, varwidth=TRUE)

df <- data.frame(mean_exp = log(rowMeans(filtered)+0.01), dropouts=rowMeans(filtered==0),
                 length=cut(length[rownames(filtered)], 
                            breaks = quantile(length[names(xx)], probs=seq(0, 1, 0.05))),
                 type=type[rownames(filtered)])

df <- na.omit(df)
ggplot(df, aes(x=mean_exp, y=length, group=length, height=..density..)) +
     geom_joy(scale=4) +
     scale_y_discrete(expand=c(0.01, 0)) +
     scale_x_continuous(expand=c(0, 0)) + theme_joy()

ggplot(df, aes(x=dropouts, y=length, group=length, height=..density..)) +
     geom_joy(scale=4) +
     scale_y_discrete(expand=c(0.01, 0)) +
     scale_x_continuous(expand=c(0, 0)) + theme_joy()

## Could it be explained by the different gene types?
library(magrittr)
library(dplyr)
df %>%
  filter(type=="protein_coding") %>%
  ggplot(aes(x=dropouts, y=length, group=length, height=..density..)) +
     geom_joy(scale=4) +
     scale_y_discrete(expand=c(0.01, 0)) +
     scale_x_continuous(expand=c(0, 0)) + theme_joy()

df %>%
  filter(type=="protein_coding") %>%
  ggplot(aes(x=mean_exp, y=length, group=length, height=..density..)) +
     geom_joy(scale=4) +
     scale_y_discrete(expand=c(0.01, 0)) +
     scale_x_continuous(expand=c(0, 0)) + theme_joy()
```

We should look at other datasets and see if the observations are true in general.

What are these highly expressed genes?

```{r high}
idx <- rownames(head(df[order(df$mean_exp, decreasing=TRUE),], 50))
fData(t4k_exp)[idx,]
```

Interestingly, these are a lot of ribosomal genes, which are probably a proxy 
for library size / amount of RNA? I bet that these ribosomal genes tend to be shorter.

```{r ribo}
ribo <- grep("^RPL", fData(t4k_exp)[,2])
idx <- rownames(fData(t4k_exp))[ribo]
boxplot(list(RPL=length[idx],
             Other=length[setdiff(names(length), idx)]), log='y')
```

My guess is that including an indicator for ribosomal genes in V should reduce
the dependence on the length.

Could it be possible that just adding some random covariates we get a better projection?
Or that by chance we were lucky to converge to a better local maxima?

```{r}
registerDoParallel(4)
register(DoparParam())

Vmod <- model.matrix(~log(length), data=bm)
system.time(zinb_len <- zinbFit(dense, K=3, V=Vmod))

Vmod <- model.matrix(~percentage_gene_gc_content, data=bm)
system.time(zinb_gconly <- zinbFit(dense, K=3, V=Vmod))

ribo <- as.numeric(grepl("^RPL", fData(t4k_exp)[rownames(dense),2]))
Vmod <- model.matrix(~ribo)
system.time(zinb_ribo <- zinbFit(dense, K=3, V=Vmod))

rand_df <- data.frame(x1 = rnorm(NROW(dense)), x2 = rnorm(NROW(dense)))
Vrand <- model.matrix(~x1, data=rand_df)
system.time(zinb_rand <- zinbFit(dense, K=3, V=Vrand))

Vrand <- model.matrix(~x1 + x2, data=rand_df)
system.time(zinb_rand2 <- zinbFit(dense, K=3, V=Vrand))
```

```{r}
plot(getW(zinb_res), pch=19, col=pal[clus], main="No covariates")

plot(getW(zinb_len), pch=19, col=pal[clus], main="Length only")
plot(getW(zinb_gconly), pch=19, col=pal[clus], main="GCC only")
plot(getW(zinb_gcc), pch=19, col=pal[clus], main="Length + GCC")
plot(getW(zinb_ribo), pch=19, col=pal[clus], main="Ribosomal genes")

plot(getW(zinb_rand), pch=19, col=pal[clus], main="One random covariate")
plot(getW(zinb_rand2), pch=19, col=pal[clus], main="Two random covariates")
```
