---
title: "Simulations from Allen"
author: "Fanny, Davide, Sandrine"
date: "01/12/2017"
output: 
  html_document: 
    fig_height: 10
    fig_width: 10
    toc: yes
    code_folding: hide
    toc_float: yes
---

```{r options, echo=FALSE, results="hide",mesasge=FALSE, error=FALSE, include=FALSE, autodep=TRUE}
knitr::opts_chunk$set(fig.align="center", cache=TRUE, error=FALSE,
                      message=FALSE, warning=TRUE, fig.width=6, fig.height=6,
                      fig.asp=1)
library(scRNAseq)
library(zinb)
library(EDASeq)
library(ggplot2)
library(matrixStats)
library(reshape)
library(ggplot2)
library(RColorBrewer)
library(knitr)
library(mclust)
require(MASS)
cols <- brewer.pal(8, "Set1")
cols2 <- c(brewer.pal(8, "Set2"), brewer.pal(8, "Set3"), brewer.pal(8, "Set1"))
set.seed(1824)
```

# Simulation plan
```{r simSummary}
simSummary = data.frame(realData = c(rep('Allen', 3),rep('Zeisel',3)),
                        K = rep(2, 6),
                        nclusters = rep(3, 6),
                        ncells =  rep('100', 6),
                        zeroFract = rep(c(.25, .5, .75),2))
kable(simSummary)                    
```

Steps are as follow  
1. Filter out the genes that do not have at least 5 counts in at least 5 cells.   
2. Sample at random 1000 genes.   
3. Fit zinb to get $W$, $\gamma_{\mu}$, $\gamma_{\pi}$, $\alpha_{\mu}$, $\alpha_{\pi}$, $\beta_{\mu}$, $\beta_{\pi}$, and $\zeta$.  
4. Simulate $W$ from multivariate gaussians fitted using mclust package. It becomes the truth W. Keeping the total variance constant, change the variance between and within the clusters.   
5. Simulate $\gamma_{\pi}$ and $\gamma_{\mu}$ from bivariate gaussians. They become the truth $\gamma_{\pi}$ and $\gamma_{\mu}$. Change mean of $\gamma_{\pi}$ to get different zero fractions.  
6. Create zinb model = zinbModel(simW, $\beta_{\mu}$,$\beta_{\pi}$, simGammaMu, simGammaPi, $\alpha_{\mu}$, $\alpha_{\pi}$, $\zeta$).  
7. Simulate counts nrep times using zinbSim(model).   

Using this procedure, we have the simulated counts and true $W$, $\gamma_{\mu}$, $\gamma_{\pi}$, $\alpha_{\mu}$, $\alpha_{\pi}$, $\beta_{\mu}$, $\beta_{\pi}$, and $\zeta$ where the paramters are   

- dataset (Allen or Zeisel),  
- ncells (100, 1000, 10000),  
- zero fraction (0.25, 0.5, 0.75),
- within/between variance (fitted variance, increased within variance).  

Throughout, we keep constant     

- number of genes ngenes. Here ngenes = 1000.  
- number of datasets to simulate from the same model. Here nrep = 10.  
- number of clusters nclust. Here nclust = 3.    
- K = 2.  
- Xint = TRUE.   
- Vint = TRUE.   
- dispersion = genewise.   



# ZINB fit
```{r datain}
data("allen")
prefilter <- allen[grep("^ERCC-", rownames(allen), invert = TRUE),
                    which(colData(allen)$Core.Type=="Core")]
filterGenes <- apply(assay(prefilter) > 5, 1, sum) >= 5
postfilter <- prefilter[filterGenes, ]

core <- assay(postfilter)
#vars <- rowVars(log1p(core))
#names(vars) <- rownames(core)
#vars <- sort(vars, decreasing = TRUE)
#core <- core[names(vars)[1:1000],]
core = core[sample(1:nrow(core), 1000),]

bioIni =  as.factor(colData(postfilter)$driver_1_s)
cl <- as.factor(colData(postfilter)$Primary.Type)
pZero <- rowMeans(log1p(core) == 0)
names(pZero) <- rownames(core)
#sum(core == 0)/(nrow(core) * ncol(core))
```

We use Allen dataset with all cells and 1000 randomly selected genes. The dimensions are
```{r dim}
dim(core)
```

Colors in left panel correspond to the area of the brain the cells were sampled from. Colors in right panel correspond to the inferred clusters in Allen paper.
```{r pcaIni}
par(mfrow = c(1,2))
fq <- betweenLaneNormalization(core, which="full")
pca <- prcomp(t(log1p(fq)))
plot(pca$x, col=cols[bioIni], pch=19, main="PCA of log-counts")
#legend("bottomleft", levels(bio), fill=cols)
plot(pca$x, col=cols2[cl], pch=19, main="PCA of log-counts")
```

Fit data with K = 2, V and X intercepts in both Mu and Pi, commondispersion = FALSE, and no covariate.
```{r zinb}
print(system.time(zinb <- zinbFit(core, ncores = 3, K = 2,
                                  commondispersion = FALSE)))
```

Check correlations between $W$, $\gamma_{mu}$, $\gamma_{pi}$, detection rate, and coverage.    

W is not correlated with $\gamma_{\mu}$ and $\gamma_{\pi}$.   
$\gamma_{\mu}$ and $\gamma_{\pi}$ are correlated.   
$\gamma_{\mu}$ is correlated with coverage.    
$\gamma_{\pi}$ is correlated with detection rate.  

In what follow, we assume that $W$ and $\gamma$ are independent. We simulate $W$ and $\gamma$ separetely from bivariate gaussians. For W, we fit a mixture of gaussians specifying the number of clusters (K = 3 here).
```{r gammaDetectionRate}
detection_rate <- colMeans(core>0)
coverage <- colSums(core)
df <- data.frame(W1 = zinb@W[,1], W2 = zinb@W[,2],
                 gamma_mu = zinb@gamma_mu[1, ],
                 gamma_pi = zinb@gamma_pi[1, ],
                 detection_rate = detection_rate,
                 coverage = coverage)
pairs(df, pch=19, col=cols[bioIni])
print(cor(df, method="spearman"))
```

Additionally, let's check $\alpha$ and $\beta$.
```{r alpha}
df <- data.frame(alpha_mu_1 = zinb@alpha_mu[1, ],
                 alpha_mu_2 = zinb@alpha_mu[2, ],
                 alpha_pi_1 = zinb@alpha_pi[1, ],
                 alpha_pi_2 = zinb@alpha_pi[2, ])
pairs(df, pch=19, main = 'alpha')
print(cor(df, method="spearman"))
```

```{r beta}
df <- data.frame(beta_mu = zinb@beta_mu[1, ],
                 beta_pi = zinb@beta_pi[1, ])
pairs(df, pch=19, main = 'Beta')
print(cor(df, method="spearman"))
```

Pick number of cells to simulate. Here
```{r ncells}
ncells = 100
ncells
```

Pick number of clusters to simulate. Here
```{r nclust}
nclust = 3
nclust
```


# W
## From real data
We simulate $W$ from three bivariate gaussians.
```{r plotmclust}
par(mfrow = c(1,3))
# zinbW
xlim = c(min(zinb@W[,1]) - 1, max(zinb@W[,1]) + 1) 
ylim = c(min(zinb@W[,2]) - 1, max(zinb@W[,2]) + 1)
plot(zinb@W, col = cols[bioIni], xlim = xlim, ylim = ylim,
     main = 'zinb fitted W\ncolor = brain area')

# mclustW
mclustW = Mclust(zinb@W, G = nclust)
plot(mclustW$data, main = 'multivar gauss fit\nmclust K = 3', xlab = 'W1', ylab = 'W2', 
     xlim = xlim, ylim = ylim, col = mclustW$classification)

# multivar gaussian
clust = sample(mclustW$classification, ncells)
simW1 = lapply(clust, function(i){
  mvrnorm(n = 1, mu = mclustW$parameters$mean[, i], 
          Sigma = mclustW$parameters$variance$sigma[,, i])
})
simW1 = do.call(rbind, simW1)
bio = clust
plot(simW1, col = bio, main = 'multivar gauss sim\ntrue W\n100 cells',
     xlab = 'W1', ylab = 'W2', xlim = xlim, ylim = ylim)
par(mfrow = c(1, 1))
```

## Change within cluster variance
$N$ = total number of cells.  
$K$ = number of cluters. Here K = 3.  
$n_k$ = number of cells classified in cluster $k$.  
$\bar{W}$ = mean of W.  
$\bar{W_k}$ = mean of W for cells in cluster $k$.  


$$V_{TOTAL} = \frac{1}{N-1} \sum_{k=1}^K \sum_{i=1}^{n_k} (W_{ik} - \bar{W})^2$$
$$V_{TOTAL} = \frac{1}{N-1} (\sum_{k=1}^K \sum_{i=1}^{n_k} (W_{ik} - \bar{W_k})^2 + \sum_{k=1}^K n_k (\bar{W_k} - \bar{W})^2)$$
$$V_{TOTAL} = \frac{1}{N-1} (S_{INTRA} + \sum_{k=1}^K n_k (\bar{W_k} - \bar{W})^2)$$

with $S_{INTRA} = \sum_{k=1}^K \sum_{i=1}^{n_k} (W_{ik} - \bar{W_k})^2$.


We want to keep the total variance constant so that the values of W stay in the same domain as the domain of the true values of W. Keeping the total variance constant, we want to vary the within and between clusters variance so that we have a way to ease the problem or make it harder. Let's replace $\bar{W_k}$ -> $a \bar{W_k}$ and $S_{INTRA}$ -> $b^2 S_{INTRA}$.  

Then,
$$V_{TOTAL} = \frac{1}{N-1} (b^2 S_{INTRA} + \sum_{k=1}^K n_k (a \bar{W_k} - \bar{W})^2)$$

$$ b^2 = \frac{1}{S_{INTRA}} ((N-1)V_{TOTAL} - \sum_{k=1}^K n_k (a \bar{W_k} - \bar{W})^2)$$ 

```{r snrLike}
computeB2 = function(mclustW, a = 1){
  N = nrow(mclustW$data)
  Vtot = apply(mclustW$data, 2, var)
  
  Vinter = (a * mclustW$parameters$mean - apply(mclustW$data, 2, mean))^2
  nk = as.vector(table(mclustW$classification))
  Vinter = as.vector(Vinter %*% nk)
  
  mk = sapply(mclustW$classification, function(i) mclustW$parameters$mean[,i])
  Vintra = apply((mclustW$data - t(mk))^2, 2, sum)
  
  ( 1 / Vintra ) * ( (N-1) * Vtot - Vinter )
}

a = seq(-1.5, 1.5, 0.01)
ylim = c(-1, 5)
b2 = sapply(a, function(x) computeB2(mclustW, x))
par(mfrow = c(1,2))
plot(a, t(b2)[,1], type = 'l', ylab = 'b2_1', xlab = 'a_1', ylim=ylim)
abline(h = 0, col= 'red')
abline(h = 1, col= 'green')
rect(a[1], ylim[1], a[length(a)], 0, density = 10,
     col = 'red', border = "transparent", lty = par("lty"), lwd = par("lwd"))
plot(a, t(b2)[,2], type = 'l', ylab = 'b2_2', xlab = 'a_2', ylim=ylim)
abline(h = 0, col= 'red')
abline(h = 1, col= 'green')
rect(a[1], ylim[1], a[length(a)], 0, density = 10,
     col = 'red', border = "transparent", lty = par("lty"), lwd = par("lwd"))
```

Check that code works for a = 0 and b = 0.
```{r WsnrlikeExtreme}
par(mfrow = c(1,3))
# zinbW
xlim = c(min(zinb@W[,1]) - 1, max(zinb@W[,1]) + 1) 
ylim = c(min(zinb@W[,2]) - 1, max(zinb@W[,2]) + 1)
plot(simW1, col = bio, main = 'multivar gauss sim\na=1',
     xlab = 'W1', ylab = 'W2', xlim = xlim, ylim = ylim)

a = c(0, 0)
b2 = computeB2(mclustW, a)
simW = lapply(clust, function(i){
  mvrnorm(n = 1, mu = mclustW$parameters$mean[, i] * a, 
          Sigma = mclustW$parameters$variance$sigma[,, i] * b2)
})
simW = do.call(rbind, simW)
plot(simW, col = bio, main = 'multivar gauss sim\na=0',
     xlab = 'W1', ylab = 'W2', xlim = xlim, ylim = ylim)

a = c(1.133, 1.222)
b2 = computeB2(mclustW, a)
simW = lapply(clust, function(i){
  mvrnorm(n = 1, mu = mclustW$parameters$mean[, i] * a, 
          Sigma = mclustW$parameters$variance$sigma[,, i] * b2)
})
simW = do.call(rbind, simW)
plot(simW, col = bio, main = 'multivar gauss sim\nb very small',
     xlab = 'W1', ylab = 'W2', xlim = xlim, ylim = ylim)
```

```{r WsnrlikeNormal}
par(mfrow = c(1,2))
# zinbW
xlim = c(min(zinb@W[,1]) - 1, max(zinb@W[,1]) + 1) 
ylim = c(min(zinb@W[,2]) - 1, max(zinb@W[,2]) + 1)
plot(simW1, col = bio, main = 'multivar gauss sim\ntrue W, 100 cells\na=1, b2=1',
     xlab = 'W1', ylab = 'W2', xlim = xlim, ylim = ylim)

a = c(.85, .7)
b2 = computeB2(mclustW, a)
simW2 = lapply(clust, function(i){
  mvrnorm(n = 1, mu = mclustW$parameters$mean[, i] * a, 
          Sigma = mclustW$parameters$variance$sigma[,, i] * b2)
})
simW2 = do.call(rbind, simW2)
plot(simW2, col = bio, main = 'multivar gauss sim\ntrue W, 100 cells\nb2=2',
     xlab = 'W1', ylab = 'W2', xlim = xlim, ylim = ylim)
```

```{r w}
simW = list(simW1, simW2)
```


# Gamma
## From real data
```{r gamma}
gamma = data.frame(gammaMu = zinb@gamma_mu[1, ],
                   gammaPi = zinb@gamma_pi[1, ])

par(mfrow = c(1,3))
# zinbGamma
xlim = c(min(gamma[,1]) - .5, max(gamma[,1]) + .5) 
ylim = c(min(gamma[,2]) - .5, max(gamma[,2]) + .5)
plot(gamma[,1], gamma[,2], col = cols[bioIni],
     xlim = xlim, ylim = ylim, xlab = 'gamma_mu', ylab = 'gamma_pi', 
     main = 'zinb fitted Gamma\ncolor = brain area')

# mclustW
mclustGamma = Mclust(gamma, G = 1)
plot(mclustGamma$data, main = 'bivar gauss fit\nmclust K = 1',
     xlab = 'gamma_mu', ylab = 'gamma_pi', 
     xlim = xlim, ylim = ylim)

# multivar gaussian
simGamma = mvrnorm(n = ncells, mu = mclustGamma$parameters$mean[,1], 
                    Sigma = mclustGamma$parameters$variance$sigma[,, 1])
plot(simGamma, col = bio, main = 'bivar gauss sim\ntrue Gamma\n100 cells',
     xlab = 'gamma_mu', ylab = 'gamma_pi', xlim = xlim, ylim = ylim)
par(mfrow = c(1, 1))
```


Let's simulate counts from the simulated $W$, $\gamma_{\mu}$, and $\gamma_{\pi}$. Zero fraction of the simulated counts is
```{r modOriginal}
mod = zinbModel(W=simW[[1]], gamma_mu = matrix(simGamma[,1], nrow = 1),
                gamma_pi = matrix(simGamma[,2], nrow = 1),
                alpha_mu=zinb@alpha_mu, alpha_pi=zinb@alpha_pi,
                beta_mu=zinb@beta_mu, beta_pi=zinb@beta_pi, zeta = zinb@zeta)
sim = zinbSim(mod, seed = 8746)
core = t(sim$counts)
sum(core == 0)/(nrow(core) * ncol(core))
```

## Changing zero fraction
We want three different zero fractions (25\%, 45\%, 75\%).  
QUESTION: TRANSLATION or RE-SIMULATION CHANGING MEAN? I did the second.
```{r gammaPi}
gammaOffset = c('25' = -3.5, '45' = 0, '75' = 3.6)
simGamma = lapply(gammaOffset, function(i){
  mvrnorm(n = ncells, mu = mclustGamma$parameters$mean[,1] + c(0, i),
          Sigma = mclustGamma$parameters$variance$sigma[,, 1])
})
```

# Models
```{r models}
models = lapply(1:2, function(k){
  lapply(1:3, function(i){
    zinbModel(W=simW[[k]], gamma_mu = matrix(simGamma[[i]][,1], nrow = 1),
              gamma_pi = matrix(simGamma[[i]][,2], nrow = 1),
              alpha_mu=zinb@alpha_mu, alpha_pi=zinb@alpha_pi,
              beta_mu=zinb@beta_mu, beta_pi=zinb@beta_pi, zeta = zinb@zeta)
  })
})

pal = colorRampPalette(c("black","black", "red","yellow"), space="rgb")
par(mfrow=c(2, 3))
for (k in 1:2){
  for (i in 1:3){
    smoothScatter(colMeans(log1p(getMu(models[[k]][[i]]))), 
                  colMeans(getPi(models[[k]][[i]])), nbin = 256,
                  nrpoints = Inf, pch = "", cex = .7, xlim = c(0,15),
                  xlab = "Average simulated log Mu",
                  main = paste0('var',k,'_z',names(gammaOffset)[i]),
                  ylab = "Average simulated Pi",ylim = c(0,1),
                  colramp = pal)
  }
}
```

# 10 replicates 
```{r bio}
B = 10
bio = clust
```

```{r rep10}
sim = lapply(1:2, function(k){
  lapply(1:3, function(i){
    simModel = models[[k]][[i]]
    simData = lapply(seq_len(B), function(i){
      zinbSim(simModel, seed = i*k)
    })
    fileName = sprintf("./datasets/simAllen_var%s_z%s.rda",
                       k, names(gammaOffset[i]))
    save(bio, simModel, simData, file = fileName)  
    sapply(simData, function(x) x$zeroFraction)
  })
})
zeroFrac = data.frame(do.call(cbind, do.call(cbind, sim)), stringsAsFactors = F)
colnames(zeroFrac) = c(paste0('var1_z', names(gammaOffset)),
                       paste0('var2_z', names(gammaOffset)))
ggplot(melt(zeroFrac), aes(x = variable, y = value)) + xlab('') + theme_bw() +
  geom_boxplot() + xlab('zero fraction') +
  theme_bw() + ylab('simulated zero fraction')
```

Let's look at one simulated dataset for each zero fraction.
```{r plots}
par(mfrow=c(2, 3))
for (k in 1:2){
  for (i in 1:3){
    fileName = sprintf("./datasets/simAllen_var%s_z%s.rda",
                       k, names(gammaOffset[i]))
    load(fileName)
    counts = simData[[1]]$counts
    zero_rate <- rowMeans(counts == 0)
    plot(rowMeans(getPi(models[[k]][[i]])), zero_rate,
         main = paste0('var', k, '_z', names(gammaOffset)[k]),
         xlab="Average simulated Pi", ylab="Simulated Zero Rate",
         pch=19, col=bio, ylim = c(0, 1), xlim = c(0,1))
    abline(a=0,b=1,col='gray')
  }
}

par(mfrow=c(2, 3))
for (k in 1:2){
  for (i in 1:3){
    fileName = sprintf("./datasets/simAllen_var%s_z%s.rda",
                       k, names(gammaOffset[i]))
    load(fileName)
    counts = simData[[1]]$counts
    coverage <- rowSums(counts)
    plot(rowMeans(log1p(getMu(models[[k]][[i]]))), log1p(coverage),
         xlim = c(4, 8),
         xlab="Average simulated log Mu", ylab="log Coverage", pch=19,
         col=bio,ylim = c(10,15), 
         main = paste0('var', k, '_z', names(gammaOffset)[k]))
  }
}
```





