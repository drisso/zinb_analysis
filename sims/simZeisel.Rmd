---
title: "Simulations from Zeisel"
author: "Fanny, Davide, Sandrine"
date: "01/12/2017"
output: 
  html_document: 
    fig_height: 10
    fig_width: 10
    toc: yes
    code_folding: hide
    toc_float: yes
---

```{r options, echo=FALSE, results="hide",mesasge=FALSE, error=FALSE, include=FALSE, autodep=TRUE}
knitr::opts_chunk$set(fig.align="center", cache=TRUE, error=FALSE,
                      message=FALSE, warning=TRUE, fig.width=6, fig.height=6)
library(scRNAseq)
library(zinb)
library(EDASeq)
library(ggplot2)
library(matrixStats)
library(reshape)
library(ggplot2)
library(RColorBrewer)
library(knitr)
library(mclust)
require(MASS)
cols <- brewer.pal(8, "Set1")
cols2 <- c(brewer.pal(8, "Set2"), brewer.pal(8, "Set3"), brewer.pal(8, "Set1"))
set.seed(9687)
```

# ZINB fit to get true parameters
```{r datain}
data <- read.table("datasets/expression_mRNA_17-Aug-2014.txt", sep='\t', stringsAsFactors = FALSE, comment.char = '%')

level1 <- as.factor(as.matrix(data)[9,-(1:2)])
tissue <- as.factor(as.matrix(data)[1,-(1:2)])
group <- as.factor(as.matrix(data)[2,-(1:2)])
nmolecule <- as.numeric(as.matrix(data)[3,-(1:2)])
sex <- as.factor(as.matrix(data)[5,-(1:2)])
level2 <- as.factor(as.matrix(data)[10,-(1:2)])

counts <- as.matrix(data[12:NROW(data),-(1:2)])
counts <- matrix(as.numeric(counts), ncol=ncol(counts), nrow=nrow(counts))
rownames(counts) <- data[12:NROW(data),1]
colnames(counts) <- data[8, -(1:2)]

filter = sample(1:ncol(counts), 300, replace = F)
counts = counts[, filter]
group = droplevels(group[filter])
sex = sex[filter]
tissue = tissue[filter]
level1 = droplevels(level1[filter])
level2 = level2[filter]
filterGenes = apply(counts > 5, 1, sum) >= 5
counts <- counts[filterGenes, ]

#vars <- rowVars(log1p(counts))
#names(vars) <- rownames(counts)
#vars <- sort(vars, decreasing = TRUE)
#core <- counts[names(vars)[1:1000],]
core <- counts[sample(1:nrow(counts), 1000),]
sum(core == 0)/(ncol(core) * nrow(core))

col1 <- brewer.pal(9, "Set1")
col2 <- brewer.pal(8, "Set2")
colTissue <- col1[tissue]
colMerged <- col2[level1]
```

We use Zeisel dataset with all cells and only 1000 randomly selected genes. The dimensions are
```{r dim}
dim(core)

table(tissue)
table(tissue, group)
table(tissue, sex)
table(level1)
```

Colors in left panel correspond to ? . Colors in right panel correspond to ?.
```{r pcaIni}
par(mfrow=c(1, 2))
fq <- EDASeq::betweenLaneNormalization(core, which="full")
pcafq <- prcomp(t(log1p(fq)))
plot(pcafq$x, col=colMerged, pch=20, main="PCA of FQ log-counts, centered not scaled")
plot(pcafq$x, col=colTissue, pch=20, main="PCA of FQ log-counts, centered not scaled")
```

Fit data with K = 2, V and X intercepts in both Mu and Pi, commondispersion = FALSE, and no covariate.

```{r zinb}
print(system.time(zinb <- zinbFit(core, ncores = 3, K = 2,
                                  commondispersion = FALSE)))
```

PROBLEM : I set (commondispersion = FALSE), but zeta is the same for all the genes.
```{r zeta}
head(getZeta(zinb))
```

It means that the dispersion $\phi = \frac{1}{\theta} = exp(-\zeta)$ is very small, i.e., we could use a Poisson distribution instead of a NB ???
```{r disp}
head(exp(-getZeta(zinb)))
```

Check correlations between $W$, $\gamma_{mu}$, $\gamma_{pi}$, detection rate, and coverage.    

W is correlated with $\gamma_{\mu}$ and $\gamma_{\pi}$.   
$\gamma_{\mu}$ and $\gamma_{\pi}$ are correlated.   
$\gamma_{\mu}$ is correlated with coverage.    
$\gamma_{\pi}$ is correlated with detection rate.  

In what follow, we assume that $W$ and $\gamma$ are independent. We simulate $W$ and $\gamma$ separetely from bivariate gaussians. For W, we fit a mixture of gaussians specifying the number of clusters (K = 3 here).
```{r gammaDetectionRate}
detection_rate <- colMeans(core>0)
coverage <- colSums(core)
df <- data.frame(W1 = zinb@W[,1], W2 = zinb@W[,2],
                 gamma_mu = zinb@gamma_mu[1, ],
                 gamma_pi = zinb@gamma_pi[1, ],
                 detection_rate = detection_rate,
                 coverage = coverage)
pairs(df, pch=19, col=colMerged)
print(cor(df, method="spearman"))
```

Additionally, let's check $\alpha$ and $\beta$.
```{r alpha}
df <- data.frame(alpha_mu_1 = zinb@alpha_mu[1, ],
                 alpha_mu_2 = zinb@alpha_mu[2, ],
                 alpha_pi_1 = zinb@alpha_pi[1, ],
                 alpha_pi_2 = zinb@alpha_pi[2, ])
pairs(df, pch=19, main = 'alpha')
print(cor(df, method="spearman"))
```

```{r beta}
df <- data.frame(beta_mu = zinb@beta_mu[1, ],
                 beta_pi = zinb@beta_pi[1, ])
pairs(df, pch=19, main = 'Beta')
print(cor(df, method="spearman"))
```

Pick number of cells to simulate. Here
```{r ncells}
ncells = 100
ncells
```

Pick number of clusters to simulate. Here
```{r nclust}
nclust = 3
nclust
```


# W
## From real data
We simulate $W$ from three bivariate gaussians.
```{r plotmclust, fig.width=6, fig.height=6}
mar <- par("mar")
mar[c(2, 4)] <- 0
par(mfrow = c(1,3), mar = mar)
# zinbW
xlim = c(min(zinb@W[,1]) - 1, max(zinb@W[,1]) + 1) 
ylim = c(min(zinb@W[,2]) - 1, max(zinb@W[,2]) + 1)
plot(zinb@W, col = colMerged, xlim = xlim, ylim = ylim,pch=20,
     main = 'zinb fitted W\ncolor = brain area')

# mclustW
mclustW = Mclust(zinb@W, G = nclust)
plot(mclustW$data, main = 'multivar gauss fit\nmclust K = 3', xlab = 'W1', ylab = 'W2', pch=20,
     xlim = xlim, ylim = ylim, col = mclustW$classification)

# multivar gaussian
clust = sample(mclustW$classification, ncells)
simW1 = lapply(clust, function(i){
  mvrnorm(n = 1, mu = mclustW$parameters$mean[, i], 
          Sigma = mclustW$parameters$variance$sigma[,, i])
})
simW1 = do.call(rbind, simW1)
bio = clust
plot(simW1, col = bio, main = 'multivar gauss sim\ntrue W\n100 cells',
     xlab = 'W1', ylab = 'W2', xlim = xlim, ylim = ylim, pch=20)
par(mfrow = c(1, 1))
```

## Change within cluster variance
$N$ = total number of cells.  
$K$ = number of cluters. Here K = 3.  
$n_k$ = number of cells classified in cluster $k$.  
$\bar{W}$ = mean of W.  
$\bar{W_k}$ = mean of W for cells in cluster $k$.  


$$V_{TOTAL} = \frac{1}{N-1} \sum_{k=1}^K \sum_{i=1}^{n_k} (W_{ik} - \bar{W})^2$$
$$V_{TOTAL} = \frac{1}{N-1} (\sum_{k=1}^K \sum_{i=1}^{n_k} (W_{ik} - \bar{W_k})^2 + \sum_{k=1}^K n_k (\bar{W_k} - \bar{W})^2)$$
$$V_{TOTAL} = \frac{1}{N-1} (S_{INTRA} + \sum_{k=1}^K n_k (\bar{W_k} - \bar{W})^2)$$

with $S_{INTRA} = \sum_{k=1}^K \sum_{i=1}^{n_k} (W_{ik} - \bar{W_k})^2$.


We want to keep the total variance constant so that the values of W stay in the same domain as the domain of the true values of W. Keeping the total variance constant, we want to vary the within and between clusters variance so that we have a way to ease the problem or make it harder. Let's replace $\bar{W_k}$ -> $a \bar{W_k}$ and $S_{INTRA}$ -> $b^2 S_{INTRA}$.  

Then,
$$V_{TOTAL} = \frac{1}{N-1} (b^2 S_{INTRA} + \sum_{k=1}^K n_k (a \bar{W_k} - \bar{W})^2)$$

$$ b^2 = \frac{1}{S_{INTRA}} ((N-1)V_{TOTAL} - \sum_{k=1}^K n_k (a \bar{W_k} - \bar{W})^2)$$ 

```{r snrLike}
computeB2 = function(mclustW, a = 1){
  N = nrow(mclustW$data)
  Vtot = apply(mclustW$data, 2, var)
  
  Vinter = (a * mclustW$parameters$mean - apply(mclustW$data, 2, mean))^2
  nk = as.vector(table(mclustW$classification))
  Vinter = as.vector(Vinter %*% nk)
  
  mk = sapply(mclustW$classification, function(i) mclustW$parameters$mean[,i])
  Vintra = apply((mclustW$data - t(mk))^2, 2, sum)
  
  ( 1 / Vintra ) * ( (N-1) * Vtot - Vinter )
}

a = seq(-2, 2, 0.01)
ylim = c(-1, 8)
b2 = sapply(a, function(x) computeB2(mclustW, x))
par(mfrow = c(1,2))
plot(a, t(b2)[,1], type = 'l', ylab = 'b2_1', xlab = 'a_1', ylim=ylim)
abline(h = 0, col= 'red')
abline(h = 1, col= 'green')
rect(a[1], ylim[1], a[length(a)], 0, density = 10,
     col = 'red', border = "transparent", lty = par("lty"), lwd = par("lwd"))
plot(a, t(b2)[,2], type = 'l', ylab = 'b2_2', xlab = 'a_2', ylim=ylim)
abline(h = 0, col= 'red')
abline(h = 1, col= 'green')
rect(a[1], ylim[1], a[length(a)], 0, density = 10,
     col = 'red', border = "transparent", lty = par("lty"), lwd = par("lwd"))
```

Check that code works for a = 0 and b = 0.
```{r WsnrlikeExtreme, fig.width=6, fig.height=6}
mar <- par("mar")
mar[c(2, 4)] <- 0
par(mfrow = c(1,3), mar = mar)
# zinbW
xlim = c(min(zinb@W[,1]) - 1, max(zinb@W[,1]) + 1) 
ylim = c(min(zinb@W[,2]) - 1, max(zinb@W[,2]) + 1)
plot(simW1, col = bio, main = 'multivar gauss sim\na=1',
     xlab = 'W1', ylab = 'W2', xlim = xlim, ylim = ylim)

a = c(0, 0)
b2 = computeB2(mclustW, a)
simW = lapply(clust, function(i){
  mvrnorm(n = 1, mu = mclustW$parameters$mean[, i] * a, 
          Sigma = mclustW$parameters$variance$sigma[,, i] * b2)
})
simW = do.call(rbind, simW)
plot(simW, col = bio, main = 'multivar gauss sim\na=0',
     xlab = 'W1', ylab = 'W2', xlim = xlim, ylim = ylim)

a = c(1.071, 1.525)
b2 = computeB2(mclustW, a)
simW = lapply(clust, function(i){
  mvrnorm(n = 1, mu = mclustW$parameters$mean[, i] * a, 
          Sigma = mclustW$parameters$variance$sigma[,, i] * b2)
})
simW = do.call(rbind, simW)
plot(simW, col = bio, main = 'multivar gauss sim\nb very small',
     xlab = 'W1', ylab = 'W2', xlim = xlim, ylim = ylim)
```

```{r WsnrlikeNormal, fig.width=6, fig.height=6}
par(mfrow = c(1,2))
# zinbW
xlim = c(min(zinb@W[,1]) - 1, max(zinb@W[,1]) + 1) 
ylim = c(min(zinb@W[,2]) - 1, max(zinb@W[,2]) + 1)
plot(simW1, col = bio, main = 'multivar gauss sim\ntrue W, 100 cells\nvar1 : a=1, b2=1',
     xlab = 'W1', ylab = 'W2', xlim = xlim, ylim = ylim)

a = c(.8, .8)
b2 = computeB2(mclustW, a)
b2
simW2 = lapply(clust, function(i){
  mvrnorm(n = 1, mu = mclustW$parameters$mean[, i] * a, 
          Sigma = mclustW$parameters$variance$sigma[,, i] * b2)
})
simW2 = do.call(rbind, simW2)
plot(simW2, col = bio, main = 'multivar gauss sim\ntrue W, 100 cells\nvar2 : b2=2',
     xlab = 'W1', ylab = 'W2', xlim = xlim, ylim = ylim)
```

```{r w}
simW = list(simW1, simW2)
```


# Gamma

We fit a bivariate gaussian to $\gamma_{\pi}$ and $\gamma_{\mu}$ and use the fitted means and covariance matrix to simulate $\gamma_{\pi}$ and $\gamma_{\mu}$.  


## From real data
```{r gamma, fig.width=6, fig.height=6}
gamma = data.frame(gammaMu = zinb@gamma_mu[1, ],
                   gammaPi = zinb@gamma_pi[1, ])

mar <- par("mar")
mar[c(2, 4)] <- 0
par(mfrow = c(1,3), mar = mar)
# zinbGamma
xlim = c(min(gamma[,1]) - .5, max(gamma[,1]) + .5) 
ylim = c(min(gamma[,2]) - .5, max(gamma[,2]) + .5)
plot(gamma[,1], gamma[,2], col = colMerged,
     xlim = xlim, ylim = ylim, xlab = 'gamma_mu', ylab = 'gamma_pi', 
     main = 'zinb fitted Gamma\ncolor = brain area')

# mclustW
mclustGamma = Mclust(gamma, G = 1)
plot(mclustGamma$data, main = 'bivar gauss fit\nmclust K = 1',
     xlab = 'gamma_mu', ylab = 'gamma_pi', 
     xlim = xlim, ylim = ylim)

# multivar gaussian
simGamma = mvrnorm(n = ncells, mu = mclustGamma$parameters$mean[,1], 
                    Sigma = mclustGamma$parameters$variance$sigma[,, 1])
plot(simGamma, col = bio, main = 'bivar gauss sim\ntrue Gamma\n100 cells',
     xlab = 'gamma_mu', ylab = 'gamma_pi', xlim = xlim, ylim = ylim)
par(mfrow = c(1, 1))
```


Let's simulate counts from the simulated $W$, $\gamma_{\mu}$, and $\gamma_{\pi}$. Zero fraction of the simulated counts is
```{r modOriginal}
mod = zinbModel(W=simW[[1]], gamma_mu = matrix(simGamma[,1], nrow = 1),
                gamma_pi = matrix(simGamma[,2], nrow = 1),
                alpha_mu=zinb@alpha_mu, alpha_pi=zinb@alpha_pi,
                beta_mu=zinb@beta_mu, beta_pi=zinb@beta_pi, zeta = zinb@zeta)
sim = zinbSim(mod, seed = 8746)
core = t(sim$counts)
sum(core == 0)/(nrow(core) * ncol(core))
```

## Changing zero fraction

We want three different zero fractions (25\%, 45\%, 75\%). A zero fraction of 45\% corresponds to the real dataset zero fraction, $\gamma_{\pi}$ and $\gamma_{\mu}$ are simulated as described above. To change the zero fraction to 25\% and 75\%, we simulate $\gamma_{\pi}$ and $\gamma_{\mu}$ as before but the mean of $\gamma_{\pi}$ is changed. We keep the mean of $\gamma_{\mu}$ and the covariance matrix constant.  


```{r gammaPi}
gammaOffset = c('25' = -3.4, '45' = 0, '75' = 2.8)
simGamma = lapply(gammaOffset, function(i){
  mvrnorm(n = ncells, mu = mclustGamma$parameters$mean[,1] + c(0, i),
          Sigma = mclustGamma$parameters$variance$sigma[,, 1])
})
```

# Models
```{r models}
models = lapply(1:2, function(k){
  lapply(1:3, function(i){
    zinbModel(W=simW[[k]], gamma_mu = matrix(simGamma[[i]][,1], nrow = 1),
              gamma_pi = matrix(simGamma[[i]][,2], nrow = 1),
              alpha_mu=zinb@alpha_mu, alpha_pi=zinb@alpha_pi,
              beta_mu=zinb@beta_mu, beta_pi=zinb@beta_pi, zeta = zinb@zeta)
  })
})

pal = colorRampPalette(c("black","black", "red","yellow"), space="rgb")
par(mfrow=c(2, 3))
for (k in 1:2){
  for (i in 1:3){
    smoothScatter(colMeans(log1p(getMu(models[[k]][[i]]))), 
                  colMeans(getPi(models[[k]][[i]])), nbin = 256,
                  nrpoints = Inf, pch = "", cex = .7, xlim = c(0,4),
                  xlab = "Average simulated log Mu",
                  main = paste0('var',k,'_z',names(gammaOffset)[i]),
                  ylab = "Average simulated Pi",ylim = c(0,1),
                  colramp = pal)
  }
}
```

# 10 replicates 
```{r bio}
B = 10
bio = clust
```

```{r rep10}
sim = lapply(1:2, function(k){
  lapply(1:3, function(i){
    simModel = models[[k]][[i]]
    simData = lapply(seq_len(B), function(i){
      zinbSim(simModel, seed = i*k)
    })
    fileName = sprintf("./datasets/simZeisel_var%s_z%s.rda",
                       k, names(gammaOffset[i]))
    save(bio, simModel, simData, file = fileName)  
    sapply(simData, function(x) x$zeroFraction)
  })
})
zeroFrac = data.frame(do.call(cbind, do.call(cbind, sim)), stringsAsFactors = F)
colnames(zeroFrac) = c(paste0('var1_z', names(gammaOffset)),
                       paste0('var2_z', names(gammaOffset)))
ggplot(melt(zeroFrac), aes(x = variable, y = value)) + xlab('') + theme_bw() +
  geom_boxplot() + xlab('zero fraction') +
  theme_bw() + ylab('simulated zero fraction')
```

Let's look at one simulated dataset for each zero fraction.
```{r plots}
par(mfrow=c(2, 3))
for (k in 1:2){
  for (i in 1:3){
    fileName = sprintf("./datasets/simZeisel_var%s_z%s.rda",
                       k, names(gammaOffset[i]))
    load(fileName)
    counts = simData[[1]]$counts
    zero_rate <- rowMeans(counts == 0)
    plot(rowMeans(getPi(models[[k]][[i]])), zero_rate,
         main = paste0('var', k, '_z', names(gammaOffset)[k]),
         xlab="Average simulated Pi", ylab="Simulated Zero Rate",
         pch=19, col=bio, ylim = c(0, 1), xlim = c(0,1))
    abline(a=0,b=1,col='gray')
  }
}

par(mfrow=c(2, 3))
for (k in 1:2){
  for (i in 1:3){
    fileName = sprintf("./datasets/simZeisel_var%s_z%s.rda",
                       k, names(gammaOffset[i]))
    load(fileName)
    counts = simData[[1]]$counts
    coverage <- rowMeans(log1p(counts))
    plot(rowMeans(log1p(getMu(models[[k]][[i]]))), coverage,
         xlim = c(0, 4),
         xlab="Average simulated log Mu", ylab="Average log counts", pch=19,
         col=bio,ylim = c(0,4), 
         main = paste0('var', k, '_z', names(gammaOffset)[i]))
    abline(a=0,b=1,col='gray')
  }
}
```





