---
title: "Simulations from Zeisel"
author: "Fanny, Davide, Sandrine"
date: "11/28/2016"
output: 
  html_document: 
    fig_height: 10
    fig_width: 10
    toc: yes
    code_folding: hide
    toc_float: yes
---

```{r options, echo=FALSE, results="hide",mesasge=FALSE, error=FALSE, include=FALSE, autodep=TRUE}
knitr::opts_chunk$set(fig.align="center", cache=TRUE, error=FALSE,
                      message=FALSE, warning=TRUE, fig.width=6, fig.height=6)
library(scRNAseq)
library(zinb)
library(EDASeq)
library(ggplot2)
library(matrixStats)
library(reshape)
library(ggplot2)
library(RColorBrewer)
library(knitr)
library(mclust)
require(MASS)
cols <- brewer.pal(8, "Set1")
cols2 <- c(brewer.pal(8, "Set2"), brewer.pal(8, "Set3"), brewer.pal(8, "Set1"))
set.seed(9687)
```

# ZINB fit to get true parameters
```{r datain}
data <- read.table("~/Documents/BRAIN/gitrepo/zinb_analysis/sims/datasets/expression_mRNA_17-Aug-2014.txt", sep='\t', stringsAsFactors = FALSE, comment.char = '%')

level1 <- as.factor(as.matrix(data)[9,-(1:2)])
tissue <- as.factor(as.matrix(data)[1,-(1:2)])
group <- as.factor(as.matrix(data)[2,-(1:2)])
nmolecule <- as.numeric(as.matrix(data)[3,-(1:2)])
sex <- as.factor(as.matrix(data)[5,-(1:2)])
level2 <- as.factor(as.matrix(data)[10,-(1:2)])

counts <- as.matrix(data[12:NROW(data),-(1:2)])
counts <- matrix(as.numeric(counts), ncol=ncol(counts), nrow=nrow(counts))
rownames(counts) <- data[12:NROW(data),1]
colnames(counts) <- data[8, -(1:2)]

filter = sample(1:ncol(counts), 300, replace = F)
counts = counts[, filter]
group = droplevels(group[filter])
sex = sex[filter]
tissue = tissue[filter]
level1 = droplevels(level1[filter])
level2 = level2[filter]
filterGenes = apply(counts > 5, 1, sum) >= 5
counts <- counts[filterGenes, ]

#vars <- rowVars(log1p(counts))
#names(vars) <- rownames(counts)
#vars <- sort(vars, decreasing = TRUE)
#core <- counts[names(vars)[1:1000],]
core <- counts[sample(1:nrow(counts), 1000),]
sum(core == 0)/(ncol(core) * nrow(core))

col1 <- brewer.pal(9, "Set1")
col2 <- brewer.pal(8, "Set2")
colTissue <- col1[tissue]
colMerged <- col2[level1]
```

We use Zeisel dataset with all cells and only 1000 randomly selected genes. The dimensions are
```{r dim}
dim(core)

table(tissue)
table(tissue, group)
table(tissue, sex)
table(level1)
```

Colors in left panel correspond to ? . Colors in right panel correspond to ?.
```{r pcaIni}
par(mfrow=c(1, 2))
fq <- EDASeq::betweenLaneNormalization(core, which="full")
pcafq <- prcomp(t(log1p(fq)))
plot(pcafq$x, col=colMerged, pch=20, main="PCA of FQ log-counts, centered not scaled")
plot(pcafq$x, col=colTissue, pch=20, main="PCA of FQ log-counts, centered not scaled")
```

Fit data with K = 2, V and X intercepts in both Mu and Pi, commondispersion = FALSE, and no covariate.

CHECK COMMON DISP = FALSE
```{r zinb}
print(system.time(zinb <- zinbFit(core, ncores = 3, K = 2,
                                  commondispersion = FALSE)))
```

Check correlations between $W$, $\gamma_{mu}$, $\gamma_{pi}$, detection rate, and coverage.    

$W_1$ is correlated with $\gamma_{\mu}$ but not $\gamma_{\pi}$.   
$\gamma_{\mu}$ and $\gamma_{\pi}$ are correlated.   
$\gamma_{\mu}$ is correlated with coverage.    
$\gamma_{\pi}$ is correlated with detection rate.  

In what follow, we assume that $W$ and $\gamma_{\pi}$ are independent. We simulate $W$, $\gamma_{\pi}$, and $\gamma_{\mu}$ separetely.
```{r gammaDetectionRate}
detection_rate <- colMeans(core>0)
coverage <- colSums(core)

par(mfrow = c(1,1))
plot(zinb@W, col = colMerged, pch = 19, xlab = 'W1', ylab = 'W2', main = 'W')

df <- data.frame(W1 = zinb@W[,1], W2 = zinb@W[,2],
                 detection_rate = detection_rate,
                 coverage = coverage)
pairs(df, pch=19, col=colMerged)
print(cor(df, method="spearman"))

df <- data.frame(W1 = zinb@W[,1], W2 = zinb@W[,2],
                 gamma_mu = zinb@gamma_mu[1, ],
                 gamma_pi = zinb@gamma_pi[1, ])
pairs(df, pch=19, col=colMerged)
print(cor(df, method="spearman"))

df <- data.frame(W1 = zinb@W[,1], W2 = zinb@W[,2],
                 gamma_mu = zinb@gamma_mu[1, ],
                 gamma_pi = zinb@gamma_pi[1, ],
                 detection_rate = detection_rate,
                 coverage = coverage)
pairs(df, pch=19, col=colMerged)
print(cor(df, method="spearman"))
```

Additionally, let's check $\alpha$ and $\beta$.
```{r alpha}
df <- data.frame(alpha_mu_1 = zinb@alpha_mu[1, ],
                 alpha_mu_2 = zinb@alpha_mu[2, ],
                 alpha_pi_1 = zinb@alpha_pi[1, ],
                 alpha_pi_2 = zinb@alpha_pi[2, ])
pairs(df, pch=19, main = 'alpha')
print(cor(df, method="spearman"))
```

```{r beta}
df <- data.frame(beta_mu = zinb@beta_mu[1, ],
                 beta_pi = zinb@beta_pi[1, ])
pairs(df, pch=19, main = 'Beta')
print(cor(df, method="spearman"))
```

Pick number of cells to simulate. Here
```{r ncells}
ncells = 100
ncells
```

# W and gamma
We simulate $W$, $\gamma_{\mu}$, and $\gamma_{\pi}$ from three multivariate gaussians.
```{r plotmclust}
df <- data.frame(W1 = zinb@W[,1], W2 = zinb@W[,2],
                 gamma_mu = zinb@gamma_mu[1, ],
                 gamma_pi = zinb@gamma_pi[1, ])
pairs(df, pch=19, col=colMerged)
print(cor(df, method="spearman"))

# mclust
mclust = Mclust(df, G = 3)
pairs(mclust$data, col = mclust$classification)

# multivar gaussian
clust = sample(mclust$classification, ncells)
sim = lapply(clust, function(i){
  mvrnorm(n = 1, mu = mclust$parameters$mean[, i], 
          Sigma = mclust$parameters$variance$sigma[,, i])
})
sim = do.call(rbind, sim)
bio = clust
pairs(sim, col = bio)
print(cor(sim, method="spearman"))
par(mfrow = c(1, 1))
```

```{r simObjects}
sim_W = sim[, 1:2]
sim_gamma_mu = sim[, 3]
sim_gamma_pi = sim[, 4]
```

# Simulate counts
## Original gamma_pi
Let's simulate counts from the simulated $W$, $\gamma_{\mu}$, and $\gamma_{\pi}$. Zero fraction of the simulated counts is
```{r modOriginal}
mod = zinbModel(W=sim_W, gamma_mu = matrix(sim_gamma_mu, nrow = 1),
                gamma_pi = matrix(sim_gamma_pi, nrow = 1),
                alpha_mu=zinb@alpha_mu, alpha_pi=zinb@alpha_pi,
                beta_mu=zinb@beta_mu, beta_pi=zinb@beta_pi, zeta = zinb@zeta)
sim = zinbSim(mod, seed = 8746)
core = t(sim$counts)
dim(core)
sum(core == 0)/(nrow(core) * ncol(core))
```

```{r PCAsim}
fq <- betweenLaneNormalization(core, which="full")
pca <- prcomp(t(log1p(fq)))
plot(pca$x, col=clust, pch=19, main="PCA of log-counts")
```

## Changing gamma_pi
We want three different zero fractions (25\%, 50\%, 75\%).
```{r gammaPi}
gammaOffset = c('25' = -3.2, '50' = .3, '75' = 2.7)
gammaPi = sapply(gammaOffset, function(x){
  sim_gamma_pi + x
})
ggplot(melt(gammaPi), aes(x = factor(X2), y = value)) + theme_bw() +
  geom_boxplot() + xlab('zero fraction') +
  theme_bw() + ylab('gamma_pi')
```

```{r models}
models = lapply(1:3, function(i){
  zinbModel(W=sim_W, gamma_mu = matrix(sim_gamma_mu, nrow = 1),
            gamma_pi = matrix(gammaPi[,i], nrow = 1),
            alpha_mu=zinb@alpha_mu, alpha_pi=zinb@alpha_pi,
            beta_mu=zinb@beta_mu, beta_pi=zinb@beta_pi, zeta = zinb@zeta)
})
```

```{r checkCorr}
## check
for (i in 1:3){
  mm = models[[i]]
  cc = data.frame(mm@W[,1], mm@W[,2], mm@gamma_mu[1,], mm@gamma_pi[1,])
  print(cor(cc, method="spearman"))  
}
```

```{r plotmodel}
pal = colorRampPalette(c("black","black", "red","yellow"), space="rgb")
par(mfrow=c(1, 3))
for (k in 1:3){
  smoothScatter(colMeans(log1p(getMu(models[[k]]))), 
                colMeans(getPi(models[[k]])), nbin = 256,
                nrpoints = Inf, pch = "", cex = .7, xlim = c(0,8),
                xlab = "Average simulated log Mu", main = names(gammaOffset)[k],
                ylab = "Average simulated Pi",ylim = c(0,1),
                colramp = pal)
}
```

## 10 replicates 
```{r bio}
B = 10
bio = clust
```

```{r rep10}
sim = lapply(1:3, function(k){
  simModel = models[[k]]
  simData = lapply(seq_len(B), function(i){
    zinbSim(simModel, seed = i*k)
  })
  fileName = sprintf("./datasets/simZeisel%s.rda", names(gammaOffset[k]))
  save(bio, simModel, simData, file = fileName)  
  sapply(simData, function(x) x$zeroFraction)
})
zeroFrac = data.frame(do.call(cbind, sim), stringsAsFactors = F)
colnames(zeroFrac) = names(gammaOffset)
ggplot(melt(zeroFrac), aes(x = variable, y = value)) + xlab('') + theme_bw() +
  geom_boxplot() + xlab('zero fraction') +
  theme_bw() + ylab('simulated zero fraction')
```

Let's look at one simulated dataset for each zero fraction.
```{r plots}
par(mfrow=c(1, 3))
for (k in 1:3){
  load(sprintf("./datasets/simZeisel%s.rda", names(gammaOffset[k])))
  counts = simData[[1]]$counts
  zero_rate <- rowMeans(counts == 0)
  plot(rowMeans(getPi(models[[k]])), zero_rate, main = names(gammaOffset)[k],
     xlab="Average simulated Pi", ylab="Simulated Zero Rate",
     pch=19, col=bio, ylim = c(0, 1), xlim = c(0,1))
  abline(a=0,b=1,col='gray')
}

par(mfrow=c(1, 3))
for (k in 1:3){
  load(sprintf("./datasets/simZeisel%s.rda", names(gammaOffset[k])))
  counts = simData[[1]]$counts
  coverage <- rowSums(counts)
  plot(rowMeans(log1p(getMu(models[[k]]))), log1p(coverage), xlim = c(0, 3),
     xlab="Average simulated log Mu", ylab="log Coverage", pch=19,
     col=bio,ylim = c(3,10), main = names(gammaOffset)[k])
}
```





