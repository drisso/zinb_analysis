---
title: "Simulation results"
author: "Davide Risso"
date: '`r Sys.Date()`'
output:
  html_document
---

```{r options, echo=FALSE, results="hide",mesasge=FALSE, error=FALSE,include=FALSE}
knitr::opts_chunk$set(fig.align="center", cache=FALSE, error=FALSE, message=FALSE, echo=TRUE, warning=FALSE,results="markup")
```

Here I simulate according to the model, and I compare the EM estimates to the optim estimates, both in terms of actual values and in terms of speed.

## 10 cells, 100 genes

```{r, echo=FALSE}
source("../R/standard.R")
source("../R/reg_smallmatrix.R")
source("../R/em.R")

## true expression: from BRAIN data
set.seed(12324)
library(MASS)
library(matrixStats)
library(brainData)
data(brain01_counts)

filteredCells <- read.table("~/git/brainAnalysis/brain/data/brain01_filtered_cells.txt", as.is=TRUE)

exclude <- !(brain01_counts$Barcode %in% filteredCells[,1])
brain01 <- brain01_counts[,!exclude]

counts <- exprs(brain01)
type <- as.factor(brain01$"Cell.type")

genes <- rownames(brain01)[fData(brain01)[,3]==1]
genes <- intersect(genes, rownames(na.omit(counts)))

filtered <- filterCount(counts[genes,], nRead=10, nCell=10)

geneMap <- read.table("~/git/brainAnalysis/brain/data/gene.map", row.names=1)

ens <- rownames(geneMap)
names(ens) <- geneMap[,1]
allgenes <- ens[rownames(filtered)]

allgenes <- na.omit(allgenes)
info <- read.table("~/git/brainAnalysis/brain/data/gene.info", row.names=1)
len <- info[allgenes,1]
gcc <- info[allgenes,2]
names(len) <- names(gcc) <- names(allgenes)

allgenes <- allgenes[names(na.omit(len))]

len <- len[names(allgenes)]
gcc <- gcc[names(allgenes)]
filtered <- filtered[names(allgenes),]

filtered0 <- filtered
filtered0[filtered==0] <- NA

means <- round(rowMedians(filtered0, na.rm=TRUE))
names(means) <- rownames(filtered0)

J <- 100
n <- 10

mu_pop <- sample(means, J)

## homogeneous population == same mu across all samples
mu <- matrix(data=rep(mu_pop, n), ncol=n, nrow=J)

## sample from real GCC and length
l <- len[names(mu_pop)]
g <- gcc[names(mu_pop)]

## values based on BRAIN data
alpha0 <- rnorm(n, mean=2, sd=2)
alpha1 <- rnorm(n, mean=-1, sd=0.3)
alpha2 <- rnorm(n, mean=0, sd=0.15)
alpha3 <- rnorm(n, mean=1.15, sd=2)

logistic <- binomial()$linkinv

## generate pi = prob. of "detection"
pi <- sapply(1:n , function(i) {
  eta <- alpha0[i] + alpha1[i] * log(mu_pop) #+ alpha2[i] * log(l) + alpha3[i] * g
  return(logistic(eta))
})

## generate Z, indicator of expression
Z <- matrix(rbinom(n*J, 1, pi), ncol=n)

## generate Y, read counts (same dispersion for all genes)
Y <- matrix(data=0, ncol=n, nrow=J)
Y[Z==0] <- rnbinom(sum(Z==0), mu = mu[Z==0], size = 1)
```

```{r, echo=FALSE}
optimize <- function(Y, mu_pop) {
  ## optim (assuming we know mu)
  parameters <- c(log(rowMeans(Y)), rep(1, n), rep(-1, n), rep(log(1), J))

  X <- matrix(rep(1, n), ncol=1)
  dim(X)
  W <- model.matrix(~log(mu_pop))
  dim(W)

  nbeta <- J
  nalpha <- n*2

  fit <- optim(fn = loglik_small, gr = grad_small, par = parameters, Y=Y, Y1=Y>0, X=X, W=W, kx=nbeta, kw=nalpha, offsetx=0, offsetw=0, linkobj=binomial(), hessian = FALSE, method = "BFGS", control=list(fnscale=-1))

  betahat <- matrix(fit$par[1:nbeta], ncol=J, nrow=ncol(X))
  muhat <- t(exp(X %*% betahat))[,1]

  alphahat <- matrix(fit$par[(nbeta + 1):(nbeta + nalpha)], nrow=ncol(W), ncol=n, byrow=TRUE)
  etahat <- W %*% alphahat
  pihat <- logistic(etahat)

  thetahat <- exp(fit$par[(nalpha + nbeta + 1):length(fit$par)])
  
  return(list(muhat=muhat, pihat=pihat, thetahat=thetahat))
}

```

```{r}
print(system.time(fit1 <- optimize(Y, mu_pop)))

print(system.time(fit2 <- em(Y)))

boxplot(data.frame(EM=as.numeric(fit2$pihat - pi), optim=as.numeric(fit1$pihat - pi)), main="Pi", ylab="pihat - pi")
abline(h=0, col=2)

boxplot(data.frame(EM=log(fit2$muhat), optim=log(fit1$muhat)) - log(mu_pop), main="Mu", ylab="log(muhat) - log(mu)")
abline(h=0, col=2)

boxplot(data.frame(EM=1/fit2$thetahat, optim=1/fit1$thetahat) - 1, main="Phi", ylab="phihat - phi")
abline(h=0, col=2)

plot(1-fit2$pihat[order(fit2$muhat),1]~sort(log(fit2$muhat)), type='l', ylim=c(0, 1), ylab="1 - pihat", xlab="log(muhat)")
for(i in 2:n) {
  lines(1-fit2$pihat[order(fit2$muhat),i]~sort(log(fit2$muhat)))
}

hist(fit2$pihat[,1])
hist(log(Y[,1]+0.1))

hist(fit2$pihat[,2])
hist(log(Y[,2]+0.1))
```

## 100 cells, 1000 genes

```{r, echo=FALSE}
J <- 1000
n <- 100

mu_pop <- sample(means, J)

## homogeneous population == same mu across all samples
mu <- matrix(data=rep(mu_pop, n), ncol=n, nrow=J)

## sample from real GCC and length
l <- len[names(mu_pop)]
g <- gcc[names(mu_pop)]

## values based on BRAIN data
alpha0 <- rnorm(n, mean=2, sd=2)
alpha1 <- rnorm(n, mean=-1, sd=0.3)
alpha2 <- rnorm(n, mean=0, sd=0.15)
alpha3 <- rnorm(n, mean=1.15, sd=2)

logistic <- binomial()$linkinv

## generate pi = prob. of "detection"
pi <- sapply(1:n , function(i) {
  eta <- alpha0[i] + alpha1[i] * log(mu_pop) #+ alpha2[i] * log(l) + alpha3[i] * g
  return(logistic(eta))
})

## generate Z, indicator of expression
Z <- matrix(rbinom(n*J, 1, pi), ncol=n)

## generate Y, read counts (same dispersion for all genes)
Y <- matrix(data=0, ncol=n, nrow=J)
Y[Z==0] <- rnbinom(sum(Z==0), mu = mu[Z==0], size = 1)
```

```{r}
print(system.time(fit1 <- optimize(Y, mu_pop)))

print(system.time(fit2 <- em(Y)))
print(fit2$convergence)

boxplot(data.frame(EM=as.numeric(fit2$pihat - pi), optim=as.numeric(fit1$pihat - pi)), main="Pi", ylab="pihat - pi")
abline(h=0, col=2)

boxplot(data.frame(EM=log(fit2$muhat), optim=log(fit1$muhat)) - log(mu_pop), main="Mu", ylab="log(muhat) - log(mu)")
abline(h=0, col=2)

boxplot(data.frame(EM=1/fit2$thetahat, optim=1/fit1$thetahat) - 1, main="Phi", ylab="phihat - phi")
abline(h=0, col=2)

plot(1-fit2$pihat[order(fit2$muhat),1]~sort(log(fit2$muhat)), type='l', ylim=c(0, 1), ylab="1 - pihat", xlab="log(muhat)")
for(i in 2:n) {
  lines(1-fit2$pihat[order(fit2$muhat),i]~sort(log(fit2$muhat)))
}

hist(fit2$pihat[,1])
hist(log(Y[,1]+0.1))

hist(fit2$pihat[,2])
hist(log(Y[,2]+0.1))

par(mfrow=c(2, 1))
boxplot(log(Y+1), outline=FALSE)
boxplot(fit2$pihat, outline=FALSE)
par(mfrow=c(1, 1))

plot(log(fit2$muhat), sqrt(1/fit2$thetahat), ylab="sqrt(phihat)", xlab="log(muhat)")
lines(lowess(sqrt(1/fit2$theta)~log(fit2$muhat)), col=2, lwd=2)
```

## TODO

* Simulate a bigger dataset to check speed
* Adapt the model to have a regression on mu
* Simulate with gene-specific dispersions (depending on mu)
* Compare to Michael's model

